import { randomUUID } from 'crypto';
import { EventEmitter } from 'events';
import type { WorkflowInstance } from '../interfaces/IStateManager';
import type { IStateManager } from '../interfaces/IStateManager';
import type {
  IWorkflowEngine,
  WorkflowDefinition,
  WorkflowStep,
  WorkflowEvent,
  WorkflowEventHandler,
} from '../interfaces/IWorkflowEngine';
import type { Logger } from '../utils/logger';
import { BaseService, ServiceConfig } from './BaseService';
import { WorkflowStateHelper } from './WorkflowStateHelper';
import { WorkflowValidator } from './WorkflowValidator';

export interface WorkflowEngineConfig extends ServiceConfig {
  maxStepRetries?: number;
  stepTimeout?: number;
  enableEventLogging?: boolean;
}

export class WorkflowEngineService
  extends BaseService
  implements IWorkflowEngine
{
  private workflows: Map<string, WorkflowDefinition> = new Map();
  private currentInstance: WorkflowInstance | null = null;
  private currentWorkflow: WorkflowDefinition | null = null;
  private eventEmitter: EventEmitter = new EventEmitter();
  private stateManager: IStateManager;
  private stateHelper: WorkflowStateHelper;
  private status: 'idle' | 'running' | 'paused' | 'completed' | 'failed' =
    'idle';

  constructor(
    config: WorkflowEngineConfig,
    logger: Logger,
    stateManager: IStateManager
  ) {
    super(config, logger);
    this.stateManager = stateManager;
    this.stateHelper = new WorkflowStateHelper(stateManager, logger);
  }

  async loadWorkflow(definition: WorkflowDefinition): Promise<void> {
    try {
      WorkflowValidator.validateWorkflowDefinition(definition);
      this.workflows.set(definition.id, definition);

      this.logger.info({
        msg: 'Workflow loaded',
        workflowId: definition.id,
        workflowName: definition.name,
      });
    } catch (error) {
      this.logger.error({
        msg: 'Failed to load workflow',
        error: (error as Error).message,
        workflowId: definition.id,
      });
      throw error;
    }
  }

  async startWorkflow(workflowId: string): Promise<WorkflowInstance> {
    try {
      const workflow = this.validateAndGetWorkflow(workflowId);
      this.checkForActiveWorkflow();

      const instance = this.createWorkflowInstance(workflowId, workflow);
      this.initializeStepStates(instance, workflow);

      this.setActiveWorkflow(instance, workflow);
      await this.persistWorkflowStart(instance);
      await this.emitWorkflowStarted(workflowId, instance.id);

      this.logWorkflowStart(workflowId, instance.id);
      return instance;
    } catch (error) {
      this.logger.error({
        msg: 'Failed to start workflow',
        error: (error as Error).message,
        workflowId,
      });
      throw error;
    }
  }

  private validateAndGetWorkflow(workflowId: string): WorkflowDefinition {
    const workflow = this.workflows.get(workflowId);
    if (!workflow) {
      throw new Error(`Workflow not found: ${workflowId}`);
    }
    return workflow;
  }

  private checkForActiveWorkflow(): void {
    if (this.currentInstance && this.currentInstance.status === 'active') {
      throw new Error('Another workflow is already running');
    }
  }

  private createWorkflowInstance(workflowId: string, workflow: WorkflowDefinition): WorkflowInstance {
    return {
      id: randomUUID(),
      workflowId,
      currentStepId: workflow.steps[0]?.id ?? '',
      startedAt: new Date(),
      updatedAt: new Date(),
      status: 'active',
      stepStates: {},
    };
  }

  private initializeStepStates(instance: WorkflowInstance, workflow: WorkflowDefinition): void {
    this.stateHelper.initializeStepStates(instance, workflow.steps);
  }

  private setActiveWorkflow(instance: WorkflowInstance, workflow: WorkflowDefinition): void {
    this.currentInstance = instance;
    this.currentWorkflow = workflow;
    this.status = 'running';
  }

  private async persistWorkflowStart(instance: WorkflowInstance): Promise<void> {
    await this.stateHelper.persistWorkflowStart(instance);
  }

  private async emitWorkflowStarted(workflowId: string, instanceId: string): Promise<void> {
    await this.emit({
      type: 'workflow-started',
      workflowId,
      instanceId,
      timestamp: new Date(),
    });
  }

  private logWorkflowStart(workflowId: string, instanceId: string): void {
    this.logger.info({
      msg: 'Workflow started',
      workflowId,
      instanceId,
    });
  }

  getCurrentStep(): WorkflowStep | null {
    return WorkflowValidator.findCurrentStep(this.currentInstance, this.currentWorkflow);
  }

  async advance(): Promise<void> {
    try {
      const { currentStep } = this.validateActiveWorkflow();

      await this.completeCurrentStep(currentStep);
      const nextStepId = this.findNextStep(currentStep);

      if (nextStepId !== null && nextStepId !== undefined && nextStepId !== '') {
        await this.moveToNextStep(nextStepId);
      } else {
        await this.completeWorkflow();
      }

      await this.saveWorkflowState();
      this.logAdvancement();
    } catch (error) {
      this.logger.error({
        msg: 'Failed to advance workflow',
        error: (error as Error).message,
      });
      throw error;
    }
  }

  async goBack(): Promise<void> {
    try {
      this.validateActiveWorkflow();

      const previousStep = this.findPreviousStep();
      this.moveToPreviousStep(previousStep);

      await this.saveWorkflowState();
      this.logGoBack();
    } catch (error) {
      this.logger.error({
        msg: 'Failed to go back in workflow',
        error: (error as Error).message,
      });
      throw error;
    }
  }

  private findPreviousStep(): WorkflowStep {
    if (!this.currentWorkflow || !this.currentInstance) {
      throw new Error('No active workflow');
    }
    return WorkflowValidator.findPreviousStep(
      this.currentWorkflow,
      this.currentInstance.currentStepId
    );
  }

  private moveToPreviousStep(previousStep: WorkflowStep): void {
    if (!this.currentInstance) {
      throw new Error('No active workflow instance');
    }
    this.currentInstance.currentStepId = previousStep.id;
    this.currentInstance.updatedAt = new Date();
    this.stateHelper.updateStepState(this.currentInstance, previousStep.id, 'pending');
  }

  private logGoBack(): void {
    if (this.currentInstance) {
      this.logger.debug({
        msg: 'Workflow moved back',
        currentStepId: this.currentInstance.currentStepId,
      });
    }
  }

  async skip(): Promise<void> {
    try {
      const { currentStep } = this.validateActiveWorkflow();

      await this.markStepAsSkipped(currentStep);
      await this.advance();

      this.logSkip(currentStep.id);
    } catch (error) {
      this.logger.error({
        msg: 'Failed to skip step',
        error: (error as Error).message,
      });
      throw error;
    }
  }

  private async markStepAsSkipped(currentStep: WorkflowStep): Promise<void> {
    if (!this.currentInstance || !this.currentWorkflow) {
      throw new Error('No active workflow');
    }
    this.stateHelper.updateStepState(
      this.currentInstance,
      currentStep.id,
      'skipped',
      new Date()
    );

    await this.emit({
      type: 'step-skipped',
      workflowId: this.currentWorkflow.id,
      instanceId: this.currentInstance.id,
      stepId: currentStep.id,
      timestamp: new Date(),
    });
  }

  private logSkip(stepId: string): void {
    this.logger.debug({
      msg: 'Step skipped',
      stepId,
    });
  }

  async reset(): Promise<void> {
    try {
      await this.emitWorkflowFailedIfActive();
      this.clearActiveWorkflow();
      await this.clearPersistedState();

      this.logger.info({ msg: 'Workflow engine reset' });
    } catch (error) {
      this.logger.error({
        msg: 'Failed to reset workflow',
        error: (error as Error).message,
      });
      throw error;
    }
  }

  private async emitWorkflowFailedIfActive(): Promise<void> {
    if (this.currentInstance && this.currentWorkflow) {
      await this.emit({
        type: 'workflow-failed',
        workflowId: this.currentWorkflow.id,
        instanceId: this.currentInstance.id,
        timestamp: new Date(),
      });
    }
  }

  private clearActiveWorkflow(): void {
    this.currentInstance = null;
    this.currentWorkflow = null;
    this.status = 'idle';
  }

  private async clearPersistedState(): Promise<void> {
    await this.stateHelper.clearPersistedState();
  }

  async pause(): Promise<void> {
    WorkflowValidator.validateRunningStatus(this.status);

    this.status = 'paused';

    if (this.currentInstance) {
      await this.pauseCurrentInstance();
    }

    this.logger.info({ msg: 'Workflow paused' });
  }

  private async pauseCurrentInstance(): Promise<void> {
    if (!this.currentInstance) {
      return;
    }

    await this.stateHelper.pauseInstance(this.currentInstance);

    await this.emit({
      type: 'workflow-paused',
      workflowId: this.currentWorkflow?.id ?? '',
      instanceId: this.currentInstance.id,
      timestamp: new Date(),
    });
  }

  async resume(): Promise<void> {
    WorkflowValidator.validatePausedStatus(this.status);

    this.status = 'running';

    if (this.currentInstance) {
      await this.resumeCurrentInstance();
    }

    this.logger.info({ msg: 'Workflow resumed' });
  }

  private async resumeCurrentInstance(): Promise<void> {
    if (!this.currentInstance) {
      return;
    }

    await this.stateHelper.resumeInstance(this.currentInstance);
  }

  getStatus(): 'idle' | 'running' | 'paused' | 'completed' | 'failed' {
    return this.status;
  }

  getInstance(): WorkflowInstance | null {
    return this.currentInstance;
  }

  on(event: WorkflowEvent['type'], handler: WorkflowEventHandler): void {
    this.eventEmitter.on(event, handler);
  }

  off(event: WorkflowEvent['type'], handler: WorkflowEventHandler): void {
    this.eventEmitter.off(event, handler);
  }

  async emit(event: WorkflowEvent): Promise<void> {
    if ((this.config as WorkflowEngineConfig).enableEventLogging === true) {
      this.logger.debug({
        msg: 'Workflow event',
        event,
      });
    }

    this.eventEmitter.emit(event.type, event);
  }

  protected async onInitialize(): Promise<void> {
    const activeInstance = await this.stateHelper.loadActiveInstance();
    if (activeInstance) {
      const workflow = this.workflows.get(activeInstance.workflowId);
      if (workflow) {
        this.currentInstance = activeInstance;
        this.currentWorkflow = workflow;
        this.status = 'running';

        this.logger.info({
          msg: 'Restored active workflow instance',
          instanceId: activeInstance.id,
          workflowId: activeInstance.workflowId,
        });
      }
    }
  }

  protected async onShutdown(): Promise<void> {
    if (this.status === 'running') {
      await this.pause();
    }
    this.eventEmitter.removeAllListeners();
  }


  private validateActiveWorkflow(): { currentStep: WorkflowStep } {
    WorkflowValidator.validateActiveWorkflow(this.currentInstance, this.currentWorkflow);

    const currentStep = this.getCurrentStep();
    if (!currentStep) {
      throw new Error('Current step not found');
    }

    return { currentStep };
  }

  private async completeCurrentStep(currentStep: WorkflowStep): Promise<void> {
    if (!this.currentInstance || !this.currentWorkflow) {
      throw new Error('No active workflow');
    }

    this.stateHelper.updateStepState(
      this.currentInstance,
      currentStep.id,
      'completed',
      new Date()
    );

    await this.emit({
      type: 'step-completed',
      workflowId: this.currentWorkflow.id,
      instanceId: this.currentInstance.id,
      stepId: currentStep.id,
      timestamp: new Date(),
    });
  }


  private async moveToNextStep(nextStepId: string): Promise<void> {
    if (!this.currentInstance || !this.currentWorkflow) {
      throw new Error('No active workflow');
    }

    this.currentInstance.currentStepId = nextStepId;
    this.currentInstance.updatedAt = new Date();

    await this.emit({
      type: 'step-started',
      workflowId: this.currentWorkflow.id,
      instanceId: this.currentInstance.id,
      stepId: nextStepId,
      timestamp: new Date(),
    });
  }

  private async completeWorkflow(): Promise<void> {
    if (!this.currentInstance || !this.currentWorkflow) {
      throw new Error('No active workflow');
    }

    this.currentInstance.status = 'completed';
    this.currentInstance.completedAt = new Date();
    this.status = 'completed';

    await this.emit({
      type: 'workflow-completed',
      workflowId: this.currentWorkflow.id,
      instanceId: this.currentInstance.id,
      timestamp: new Date(),
    });
  }

  private async saveWorkflowState(): Promise<void> {
    await this.stateHelper.saveWorkflowState(this.currentInstance);
  }

  private logAdvancement(): void {
    if (this.currentInstance) {
      this.logger.debug({
        msg: 'Workflow advanced',
        currentStepId: this.currentInstance.currentStepId,
        status: this.currentInstance.status,
      });
    }
  }

  private findNextStep(currentStep: WorkflowStep): string | null {
    if (!this.currentWorkflow) {
      return null;
    }

    return WorkflowValidator.findNextStepId(this.currentWorkflow, currentStep);
  }
}
