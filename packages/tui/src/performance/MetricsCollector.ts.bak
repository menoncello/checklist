export interface MetricPoint {
  timestamp: number;
  value: number;
  tags?: Record<string, string>;
  metadata?: Record<string, unknown>;
}

export interface MetricSeries {
  name: string;
  points: MetricPoint[];
  aggregations: {
    count: number;
    sum: number;
    avg: number;
    min: number;
    max: number;
    p50: number;
    p95: number;
    p99: number;
    latest: number;
  };
  tags: Record<string, string>;
}

export interface MetricQuery {
  name?: string;
  tags?: Record<string, string>;
  timeRange?: {
    start: number;
    end: number;
  };
  aggregateBy?: 'time' | 'tags';
  aggregateInterval?: number;
  limit?: number;
}

export interface MetricsReport {
  generatedAt: number;
  timeRange: {
    start: number;
    end: number;
  };
  summary: {
    totalMetrics: number;
    totalPoints: number;
    uniqueSeries: number;
    sampleRate: number;
  };
  series: MetricSeries[];
  alerts: MetricAlert[];
  recommendations: string[];
}

export interface MetricAlert {
  id: string;
  timestamp: number;
  metric: string;
  value: number;
  condition: string;
  severity: 'info' | 'warning' | 'error' | 'critical';
  message: string;
  tags?: Record<string, string>;
}

export interface MetricsCollectorConfig {
  enableCollection: boolean;
  bufferSize: number;
  flushInterval: number;
  compressionThreshold: number;
  retentionPeriod: number;
  enableAggregation: boolean;
  aggregationInterval: number;
  enableAlerts: boolean;
  exportFormat: 'json' | 'csv' | 'prometheus';
  persistMetrics: boolean;
  persistPath?: string;
}

export class MetricsCollector {
  private config: MetricsCollectorConfig;
  private buffer = new Map<string, MetricPoint[]>();
  private series = new Map<string, MetricSeries>();
  private alerts: MetricAlert[] = [];
  private alertRules = new Map<string, AlertRule>();
  private eventHandlers = new Map<string, Set<Function>>();
  private flushTimer: Timer | null = null;
  private aggregationTimer: Timer | null = null;
  private collectionStartTime = Date.now();
  private totalPointsCollected = 0;

  constructor(config: Partial<MetricsCollectorConfig> = {}) {
    this.config = {
      enableCollection: true,
      bufferSize: 10000,
      flushInterval: 30000, // 30 seconds
      compressionThreshold: 1000,
      retentionPeriod: 24 * 60 * 60 * 1000, // 24 hours
      enableAggregation: true,
      aggregationInterval: 60000, // 1 minute
      enableAlerts: true,
      exportFormat: 'json',
      persistMetrics: false,
      ...config,
    };

    this.setupDefaultAlertRules();

    if (this.config.enableCollection) {
      this.startCollection();
    }
  }

  private setupDefaultAlertRules(): void {
    // High memory usage alert
    this.addAlertRule({
      id: 'high-memory',
      metric: 'memory_heap_used',
      condition: 'value > 50000000', // 50MB
      severity: 'warning',
      message: 'High memory usage detected',
    });

    // High CPU usage alert
    this.addAlertRule({
      id: 'high-cpu',
      metric: 'cpu_usage',
      condition: 'value > 80',
      severity: 'warning',
      message: 'High CPU usage detected',
    });

    // Slow startup alert
    this.addAlertRule({
      id: 'slow-startup',
      metric: 'startup_time',
      condition: 'value > 100',
      severity: 'error',
      message: 'Slow startup time detected',
    });

    // High event loop delay
    this.addAlertRule({
      id: 'event-loop-delay',
      metric: 'event_loop_delay',
      condition: 'value > 50',
      severity: 'critical',
      message: 'High event loop delay detected',
    });

    // Low FPS
    this.addAlertRule({
      id: 'low-fps',
      metric: 'fps',
      condition: 'value < 30',
      severity: 'warning',
      message: 'Low frame rate detected',
    });
  }

  private startCollection(): void {
    // Start flush timer
    this.flushTimer = setInterval(() => {
      this.flushBuffer();
    }, this.config.flushInterval);

    // Start aggregation timer
    if (this.config.enableAggregation) {
      this.aggregationTimer = setInterval(() => {
        this.performAggregation();
      }, this.config.aggregationInterval);
    }

    // Start cleanup timer
    setInterval(() => {
      this.cleanup();
    }, this.config.retentionPeriod / 24); // Check every hour
  }

  public collect(
    name: string,
    value: number,
    tags?: Record<string, string>,
    metadata?: Record<string, unknown>
  ): void {
    if (!this.config.enableCollection) return;

    const point: MetricPoint = {
      timestamp: Date.now(),
      value,
      tags,
      metadata,
    };

    // Add to buffer
    if (!this.buffer.has(name)) {
      this.buffer.set(name, []);
    }

    const points = this.buffer.get(name)!;
    points.push(point);

    // Trim buffer if too large
    if (points.length > this.config.bufferSize) {
      points.splice(0, points.length - this.config.bufferSize);
    }

    this.totalPointsCollected++;

    // Check alerts
    if (this.config.enableAlerts) {
      this.checkAlerts(name, point);
    }

    // Auto-flush if buffer is getting large
    if (points.length >= this.config.bufferSize * 0.8) {
      this.flushBuffer();
    }

    this.emit('metricCollected', { name, point });
  }

  private flushBuffer(): void {
    const now = Date.now();
    let flushedCount = 0;

    for (const [name, points] of this.buffer) {
      if (points.length === 0) continue;

      // Get or create series
      let series = this.series.get(name);
      if (!series) {
        series = {
          name,
          points: [],
          aggregations: this.calculateAggregations([]),
          tags: {},
        };
        this.series.set(name, series);
      }

      // Add points to series
      series.points.push(...points);
      flushedCount += points.length;

      // Update aggregations
      series.aggregations = this.calculateAggregations(series.points);

      // Extract common tags
      if (points.length > 0 && points[0].tags) {
        series.tags = { ...points[0].tags };
      }

      // Clear buffer
      points.length = 0;
    }

    if (flushedCount > 0) {
      this.emit('bufferFlushed', {
        pointsFlushed: flushedCount,
        timestamp: now,
      });
    }
  }

  private performAggregation(): void {
    const now = Date.now();
    const interval = this.config.aggregationInterval;

    for (const [name, series] of this.series) {
      // Group points by time intervals
      const buckets = new Map<number, MetricPoint[]>();

      for (const point of series.points) {
        const bucket = Math.floor(point.timestamp / interval) * interval;
        if (!buckets.has(bucket)) {
          buckets.set(bucket, []);
        }
        buckets.get(bucket)!.push(point);
      }

      // Create aggregated points
      const aggregatedPoints: MetricPoint[] = [];

      for (const [bucketTime, points] of buckets) {
        if (points.length === 0) continue;

        const values = points.map((p) => p.value);
        const aggregatedPoint: MetricPoint = {
          timestamp: bucketTime,
          value: values.reduce((sum, v) => sum + v, 0) / values.length, // Average
          tags: {
            ...points[0].tags,
            aggregated: 'true',
            interval: interval.toString(),
            count: points.length.toString(),
          },
          metadata: {
            min: Math.min(...values),
            max: Math.max(...values),
            sum: values.reduce((sum, v) => sum + v, 0),
            count: points.length,
          },
        };

        aggregatedPoints.push(aggregatedPoint);
      }

      // Replace original points with aggregated ones if compression threshold is met
      if (series.points.length > this.config.compressionThreshold) {
        series.points = aggregatedPoints;
        series.aggregations = this.calculateAggregations(series.points);

        this.emit('seriesAggregated', {
          name,
          originalCount: buckets.size * 10, // Estimate
          aggregatedCount: aggregatedPoints.length,
        });
      }
    }
  }

  private calculateAggregations(
    points: MetricPoint[]
  ): MetricSeries['aggregations'] {
    if (points.length === 0) {
      return {
        count: 0,
        sum: 0,
        avg: 0,
        min: 0,
        max: 0,
        p50: 0,
        p95: 0,
        p99: 0,
        latest: 0,
      };
    }

    const values = points.map((p) => p.value).sort((a, b) => a - b);
    const sum = values.reduce((acc, val) => acc + val, 0);
    const count = values.length;

    return {
      count,
      sum,
      avg: sum / count,
      min: values[0],
      max: values[count - 1],
      p50: this.percentile(values, 0.5),
      p95: this.percentile(values, 0.95),
      p99: this.percentile(values, 0.99),
      latest: points[points.length - 1].value,
    };
  }

  private percentile(sortedValues: number[], p: number): number {
    const index = Math.ceil(sortedValues.length * p) - 1;
    return sortedValues[Math.max(0, index)];
  }

  private checkAlerts(metricName: string, point: MetricPoint): void {
    for (const [ruleId, rule] of this.alertRules) {
      if (rule.metric !== metricName) continue;

      const shouldAlert = this.evaluateCondition(
        rule.condition,
        point.value,
        point
      );

      if (shouldAlert) {
        const alert: MetricAlert = {
          id: `${ruleId}-${Date.now()}`,
          timestamp: point.timestamp,
          metric: metricName,
          value: point.value,
          condition: rule.condition,
          severity: rule.severity,
          message: rule.message,
          tags: point.tags,
        };

        this.alerts.push(alert);

        // Trim alerts if too many
        if (this.alerts.length > 1000) {
          this.alerts = this.alerts.slice(-1000);
        }

        this.emit('alertTriggered', { alert });
      }
    }
  }

  private evaluateCondition(
    condition: string,
    value: number,
    point: MetricPoint
  ): boolean {
    try {
      // Simple condition evaluation
      // Replace 'value' with actual value in the condition string
      const expression = condition.replace(/value/g, value.toString());

      // Basic safety check - only allow mathematical expressions
      if (!/^[\d\s+\-*/.()><!=&|]+$/.test(expression)) {
        return false;
      }

      // eslint-disable-next-line no-eval
      return eval(expression);
    } catch {
      return false;
    }
  }

  private cleanup(): void {
    const cutoff = Date.now() - this.config.retentionPeriod;
    let cleanedPoints = 0;

    for (const [name, series] of this.series) {
      const originalLength = series.points.length;
      series.points = series.points.filter((point) => point.timestamp > cutoff);
      cleanedPoints += originalLength - series.points.length;

      // Recalculate aggregations
      series.aggregations = this.calculateAggregations(series.points);

      // Remove empty series
      if (series.points.length === 0) {
        this.series.delete(name);
      }
    }

    // Clean up old alerts
    this.alerts = this.alerts.filter((alert) => alert.timestamp > cutoff);

    if (cleanedPoints > 0) {
      this.emit('cleanupPerformed', {
        cleanedPoints,
        retainedSeries: this.series.size,
      });
    }
  }

  public query(query: MetricQuery): MetricSeries[] {
    const results: MetricSeries[] = [];

    for (const [name, series] of this.series) {
      // Filter by name
      if (query.name && !name.includes(query.name)) continue;

      // Filter by time range
      let filteredPoints = series.points;
      if (query.timeRange) {
        filteredPoints = filteredPoints.filter(
          (point) =>
            point.timestamp >= query.timeRange!.start &&
            point.timestamp <= query.timeRange!.end
        );
      }

      // Filter by tags
      if (query.tags) {
        filteredPoints = filteredPoints.filter((point) => {
          if (!point.tags) return false;
          return Object.entries(query.tags!).every(
            ([key, value]) => point.tags![key] === value
          );
        });
      }

      // Apply limit
      if (query.limit) {
        filteredPoints = filteredPoints.slice(-query.limit);
      }

      if (filteredPoints.length > 0) {
        results.push({
          name,
          points: filteredPoints,
          aggregations: this.calculateAggregations(filteredPoints),
          tags: series.tags,
        });
      }
    }

    return results;
  }

  public generateReport(timeRange?: {
    start: number;
    end: number;
  }): MetricsReport {
    const now = Date.now();
    const range = timeRange ?? {
      start: now - 60 * 60 * 1000, // Last hour
      end: now,
    };

    const series = this.query({
      timeRange: range,
    });

    const totalPoints = series.reduce((sum, s) => sum + s.points.length, 0);
    const sampleRate =
      totalPoints / Math.max(1, (range.end - range.start) / 1000); // Points per second

    // Get recent alerts
    const recentAlerts = this.alerts.filter(
      (alert) => alert.timestamp >= range.start && alert.timestamp <= range.end
    );

    // Generate recommendations
    const recommendations = this.generateRecommendations(series, recentAlerts);

    return {
      generatedAt: now,
      timeRange: range,
      summary: {
        totalMetrics: this.series.size,
        totalPoints,
        uniqueSeries: series.length,
        sampleRate,
      },
      series,
      alerts: recentAlerts,
      recommendations,
    };
  }

  private generateRecommendations(
    series: MetricSeries[],
    alerts: MetricAlert[]
  ): string[] {
    const recommendations: string[] = [];

    // Analyze high-variance metrics
    for (const s of series) {
      if (s.points.length < 2) continue;

      const variance = this.calculateVariance(s.points.map((p) => p.value));
      const cv = variance / Math.max(s.aggregations.avg, 1); // Coefficient of variation

      if (cv > 0.5) {
        recommendations.push(
          `High variance detected in ${s.name} - consider investigating inconsistent performance`
        );
      }
    }

    // Analyze alert patterns
    const alertCounts = new Map<string, number>();
    for (const alert of alerts) {
      alertCounts.set(alert.metric, (alertCounts.get(alert.metric) ?? 0) + 1);
    }

    for (const [metric, count] of alertCounts) {
      if (count > 5) {
        recommendations.push(
          `Frequent alerts for ${metric} (${count} times) - consider adjusting thresholds or investigating root cause`
        );
      }
    }

    // Memory usage recommendations
    const memoryMetrics = series.filter((s) => s.name.includes('memory'));
    for (const mem of memoryMetrics) {
      if (mem.aggregations.latest > mem.aggregations.avg * 1.5) {
        recommendations.push(
          `Current ${mem.name} usage is significantly above average - consider memory optimization`
        );
      }
    }

    return recommendations;
  }

  private calculateVariance(values: number[]): number {
    if (values.length === 0) return 0;

    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDiffs = values.map((val) => Math.pow(val - mean, 2));
    return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / values.length;
  }

  public addAlertRule(rule: AlertRule): void {
    this.alertRules.set(rule.id, rule);
  }

  public removeAlertRule(id: string): boolean {
    return this.alertRules.delete(id);
  }

  public getAlertRules(): AlertRule[] {
    return Array.from(this.alertRules.values());
  }

  public getAlerts(severity?: MetricAlert['severity']): MetricAlert[] {
    if (severity) {
      return this.alerts.filter((alert) => alert.severity === severity);
    }
    return [...this.alerts];
  }

  public getSeries(): MetricSeries[] {
    return Array.from(this.series.values());
  }

  public getMetrics(): CollectorMetrics {
    const uptime = Date.now() - this.collectionStartTime;
    const totalPoints = Array.from(this.series.values()).reduce(
      (sum, series) => sum + series.points.length,
      0
    );

    return {
      uptime,
      totalSeries: this.series.size,
      totalPoints,
      totalPointsCollected: this.totalPointsCollected,
      bufferSize: Array.from(this.buffer.values()).reduce(
        (sum, points) => sum + points.length,
        0
      ),
      alertRulesCount: this.alertRules.size,
      activeAlertsCount: this.alerts.length,
      collectionRate: this.totalPointsCollected / Math.max(1, uptime / 1000), // Points per second
    };
  }

  public clearBuffer(): void {
    this.buffer.clear();
  }

  public clearSeries(): void {
    this.series.clear();
  }

  public clearAlerts(): void {
    this.alerts = [];
  }

  public clearAll(): void {
    this.clearBuffer();
    this.clearSeries();
    this.clearAlerts();
    this.totalPointsCollected = 0;
    this.collectionStartTime = Date.now();
  }

  public updateConfig(newConfig: Partial<MetricsCollectorConfig>): void {
    this.config = { ...this.config, ...newConfig };

    // Restart timers if intervals changed
    if (newConfig.flushInterval !== undefined && this.flushTimer) {
      clearInterval(this.flushTimer);
      this.flushTimer = setInterval(
        () => this.flushBuffer(),
        this.config.flushInterval
      );
    }

    if (newConfig.aggregationInterval !== undefined && this.aggregationTimer) {
      clearInterval(this.aggregationTimer);
      if (this.config.enableAggregation) {
        this.aggregationTimer = setInterval(
          () => this.performAggregation(),
          this.config.aggregationInterval
        );
      }
    }
  }

  public getConfig(): MetricsCollectorConfig {
    return { ...this.config };
  }

  public destroy(): void {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
      this.flushTimer = null;
    }

    if (this.aggregationTimer) {
      clearInterval(this.aggregationTimer);
      this.aggregationTimer = null;
    }

    this.clearAll();
    this.alertRules.clear();
    this.eventHandlers.clear();
  }

  public on(event: string, handler: Function): void {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, new Set());
    }
    const handlers = this.eventHandlers.get(event);
    if (handlers != null) {
      handlers.add(handler);
    }
  }

  public off(event: string, handler: Function): void {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      handlers.delete(handler);
    }
  }

  private emit(event: string, data?: unknown): void {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      handlers.forEach((handler) => {
        try {
          handler(data);
        } catch (error) {
          console.error(
            `Error in metrics collector event handler for '${event}':`,
            error
          );
        }
      });
    }
  }
}

export interface AlertRule {
  id: string;
  metric: string;
  condition: string;
  severity: 'info' | 'warning' | 'error' | 'critical';
  message: string;
  tags?: Record<string, string>;
}

export interface CollectorMetrics {
  uptime: number;
  totalSeries: number;
  totalPoints: number;
  totalPointsCollected: number;
  bufferSize: number;
  alertRulesCount: number;
  activeAlertsCount: number;
  collectionRate: number;
}
