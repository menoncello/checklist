export { PerformanceMonitor } from './PerformanceMonitor';
export { StartupProfiler } from './StartupProfiler';
export { MemoryTracker } from './MemoryTracker';
export { MetricsCollector } from './MetricsCollector';

export type {
  PerformanceMetric,
  PerformanceThreshold,
  PerformanceBenchmark,
  PerformanceAlert,
  PerformanceMonitorConfig,
  MetricFilter,
  BenchmarkFilter,
  MetricStatistics,
  SystemSnapshot,
} from './PerformanceMonitor';

export type {
  StartupPhase,
  StartupMilestone,
  StartupProfilerConfig,
  StartupProfile,
  TargetAnalysis,
  PhaseOptions,
  PhaseStatistics,
  BottleneckInfo,
  StartupReport,
} from './StartupProfiler';

export type {
  MemorySnapshot,
  MemoryLeak,
  MemoryTrackerConfig,
  MemoryTrend,
  MemoryStatistics,
} from './MemoryTracker';

export type {
  MetricPoint,
  MetricSeries,
  MetricQuery,
  MetricsReport,
  MetricAlert,
  MetricsCollectorConfig,
  AlertRule,
  CollectorMetrics,
} from './MetricsCollector';

import { MemoryTracker } from './MemoryTracker';
import { MetricsCollector } from './MetricsCollector';
import { PerformanceMonitor } from './PerformanceMonitor';
import { StartupProfiler } from './StartupProfiler';

export interface PerformanceManagerConfig {
  enableMonitoring: boolean;
  enableStartupProfiling: boolean;
  enableMemoryTracking: boolean;
  enableMetricsCollection: boolean;
  reportingInterval: number;
  alertsEnabled: boolean;
}

export class PerformanceManager {
  private config: PerformanceManagerConfig;
  private monitor: PerformanceMonitor;
  private startupProfiler: StartupProfiler;
  private memoryTracker: MemoryTracker;
  private metricsCollector: MetricsCollector;
  private reportingTimer: Timer | null = null;
  private eventHandlers = new Map<string, Set<Function>>();

  constructor(config: Partial<PerformanceManagerConfig> = {}) {
    this.config = {
      enableMonitoring: true,
      enableStartupProfiling: true,
      enableMemoryTracking: true,
      enableMetricsCollection: true,
      reportingInterval: 60000, // 1 minute
      alertsEnabled: true,
      ...config,
    };

    // Initialize components
    this.monitor = new PerformanceMonitor({
      enableMetrics: this.config.enableMonitoring,
      enableAlerts: this.config.alertsEnabled,
    });

    this.startupProfiler = new StartupProfiler({
      enableProfiling: this.config.enableStartupProfiling,
    });

    this.memoryTracker = new MemoryTracker({
      enableTracking: this.config.enableMemoryTracking,
    });

    this.metricsCollector = new MetricsCollector({
      enableCollection: this.config.enableMetricsCollection,
      enableAlerts: this.config.alertsEnabled,
    });

    this.setupEventHandlers();
    this.startReporting();
  }

  private setupEventHandlers(): void {
    // Forward monitor events
    this.monitor.on('metricRecorded', (data) => {
      this.metricsCollector.collect(
        data.metric.name,
        data.metric.value,
        data.metric.tags,
        data.metric.metadata
      );
      this.emit('metricRecorded', data);
    });

    this.monitor.on('performanceAlert', (data) => {
      this.emit('performanceAlert', data);
    });

    // Forward startup profiler events
    this.startupProfiler.on('phaseStarted', (data) => {
      this.emit('startupPhaseStarted', data);
    });

    this.startupProfiler.on('phaseEnded', (data) => {
      this.emit('startupPhaseEnded', data);
      // Collect phase metrics
      if (data.phase.duration) {
        this.metricsCollector.collect(
          `startup_phase_${data.phase.name}`,
          data.phase.duration,
          { phase: data.phase.name, category: 'startup' }
        );
      }
    });

    this.startupProfiler.on('startupComplete', (data) => {
      this.emit('startupComplete', data);
      // Collect overall startup metrics
      if (data.profile.totalDuration) {
        this.metricsCollector.collect(
          'startup_total_time',
          data.profile.totalDuration,
          { category: 'startup' }
        );
      }
    });

    // Forward memory tracker events
    this.memoryTracker.on('memoryAlert', (data) => {
      this.emit('memoryAlert', data);
    });

    this.memoryTracker.on('memoryLeak', (data) => {
      this.emit('memoryLeak', data);
    });

    this.memoryTracker.on('memorySnapshot', (data) => {
      // Collect memory metrics
      const snapshot = data.snapshot;
      this.metricsCollector.collect('memory_rss', snapshot.rss, {
        type: 'system',
      });
      this.metricsCollector.collect('memory_heap_used', snapshot.heapUsed, {
        type: 'system',
      });
      this.metricsCollector.collect('memory_heap_total', snapshot.heapTotal, {
        type: 'system',
      });
    });

    // Forward metrics collector events
    this.metricsCollector.on('alertTriggered', (data) => {
      this.emit('metricsAlert', data);
    });
  }

  private startReporting(): void {
    if (this.config.reportingInterval > 0) {
      this.reportingTimer = setInterval(() => {
        this.generatePerformanceReport();
      }, this.config.reportingInterval);
    }
  }

  public generatePerformanceReport(): PerformanceReport {
    const timestamp = Date.now();

    // Get data from all components
    const monitorSnapshot = this.monitor.getSystemSnapshot();
    const memoryStats = this.memoryTracker.getStatistics();
    const metricsReport = this.metricsCollector.generateReport();
    const startupProfile = this.startupProfiler.isCompleted()
      ? this.startupProfiler.generateReport()
      : null;

    // Combine into comprehensive report
    const report: PerformanceReport = {
      timestamp,
      uptime: monitorSnapshot.uptime,
      system: {
        memory: monitorSnapshot.memory,
        cpu: monitorSnapshot.cpu,
        eventLoopDelay: 0, // Will be populated from metrics
      },
      startup: startupProfile,
      memory: {
        current: memoryStats.current,
        trends: memoryStats.trends,
        leaks: this.memoryTracker.getLeaks(),
      },
      metrics: {
        totalSeries: metricsReport.summary.uniqueSeries,
        totalPoints: metricsReport.summary.totalPoints,
        sampleRate: metricsReport.summary.sampleRate,
      },
      alerts: {
        performance: this.monitor.getAlerts(),
        memory: this.memoryTracker.getLeaks().map((leak) => ({
          type: 'memory_leak',
          severity: 'critical' as const,
          message: `Memory leak detected: ${leak.type}`,
          timestamp: leak.timestamp,
          data: leak,
        })),
        metrics: this.metricsCollector.getAlerts(),
      },
      recommendations: this.generateRecommendations(metricsReport),
    };

    this.emit('performanceReport', { report });
    return report;
  }

  private generateRecommendations(metricsReport: MetricsReport): string[] {
    const recommendations: string[] = [];

    // Add metrics collector recommendations
    recommendations.push(...metricsReport.recommendations);

    // Add memory recommendations
    const memoryStats = this.memoryTracker.getStatistics();
    if (
      memoryStats.trends.some(
        (t) => t.direction === 'increasing' && t.rate > 1024 * 1024
      )
    ) {
      recommendations.push(
        'Memory usage is increasing rapidly - investigate potential memory leaks'
      );
    }

    // Add startup recommendations
    if (this.startupProfiler.isCompleted()) {
      const startupReport = this.startupProfiler.generateReport();
      if (!startupReport.profile.meetsTargets) {
        recommendations.push(
          'Startup performance targets not met - consider optimizing initialization'
        );
      }
    }

    return recommendations;
  }

  // Public API methods
  public recordMetric(
    name: string,
    value: number,
    tags?: Record<string, string>
  ): void {
    this.monitor.recordMetric({
      id: `${name}-${Date.now()}`,
      name,
      value,
      timestamp: Date.now(),
      tags,
    });
  }

  public startBenchmark(id: string, name: string, category?: string): void {
    this.monitor.startBenchmark(id, name, category);
  }

  public endBenchmark(id: string): any {
    return this.monitor.endBenchmark(id);
  }

  public measureFunction<T extends (...args: any[]) => any>(
    fn: T,
    name: string,
    category?: string
  ): T {
    return this.monitor.measureFunction(fn, name, category);
  }

  public measureAsync<T>(
    promise: Promise<T>,
    name: string,
    category?: string
  ): Promise<T> {
    return this.monitor.measureAsync(promise, name, category);
  }

  public startStartupPhase(name: string, options?: any): void {
    this.startupProfiler.startPhase(name, options);
  }

  public endStartupPhase(name: string): any {
    return this.startupProfiler.endPhase(name);
  }

  public addStartupMilestone(name: string, description?: string): void {
    this.startupProfiler.addMilestone(name, description);
  }

  public completeStartup(): any {
    return this.startupProfiler.completeStartup();
  }

  public getMemorySnapshot(): any {
    return this.memoryTracker.getCurrentSnapshot();
  }

  public triggerGC(): boolean {
    return this.memoryTracker.triggerGC();
  }

  public getSystemSnapshot(): any {
    return this.monitor.getSystemSnapshot();
  }

  public queryMetrics(query: any): any {
    return this.metricsCollector.query(query);
  }

  public getPerformanceReport(): PerformanceReport {
    return this.generatePerformanceReport();
  }

  public updateConfig(newConfig: Partial<PerformanceManagerConfig>): void {
    this.config = { ...this.config, ...newConfig };

    // Update component configs
    this.monitor.updateConfig({
      enableMetrics: this.config.enableMonitoring,
      enableAlerts: this.config.alertsEnabled,
    });

    this.memoryTracker.updateConfig({
      enableTracking: this.config.enableMemoryTracking,
    });

    this.metricsCollector.updateConfig({
      enableCollection: this.config.enableMetricsCollection,
      enableAlerts: this.config.alertsEnabled,
    });

    // Restart reporting if interval changed
    if (this.reportingTimer) {
      clearInterval(this.reportingTimer);
      this.reportingTimer = null;
    }
    this.startReporting();
  }

  public getConfig(): PerformanceManagerConfig {
    return { ...this.config };
  }

  public destroy(): void {
    if (this.reportingTimer) {
      clearInterval(this.reportingTimer);
      this.reportingTimer = null;
    }

    this.monitor.destroy();
    this.startupProfiler.destroy?.();
    this.memoryTracker.destroy();
    this.metricsCollector.destroy();
    this.eventHandlers.clear();
  }

  public on(event: string, handler: Function): void {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, new Set());
    }
    const handlers = this.eventHandlers.get(event);
    if (handlers != null) {
      handlers.add(handler);
    }
  }

  public off(event: string, handler: Function): void {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      handlers.delete(handler);
    }
  }

  private emit(event: string, data?: unknown): void {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      handlers.forEach((handler) => {
        try {
          handler(data);
        } catch (error) {
          console.error(
            `Error in performance manager event handler for '${event}':`,
            error
          );
        }
      });
    }
  }
}

export interface PerformanceReport {
  timestamp: number;
  uptime: number;
  system: {
    memory: NodeJS.MemoryUsage;
    cpu: {
      user: number;
      system: number;
    };
    eventLoopDelay: number;
  };
  startup: any | null;
  memory: {
    current: NodeJS.MemoryUsage;
    trends: any[];
    leaks: any[];
  };
  metrics: {
    totalSeries: number;
    totalPoints: number;
    sampleRate: number;
  };
  alerts: {
    performance: any[];
    memory: Array<{
      type: string;
      severity: string;
      message: string;
      timestamp: number;
      data: any;
    }>;
    metrics: any[];
  };
  recommendations: string[];
}
