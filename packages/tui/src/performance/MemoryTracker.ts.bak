export interface MemorySnapshot {
  timestamp: number;
  rss: number;
  heapTotal: number;
  heapUsed: number;
  external: number;
  arrayBuffers: number;
  peak: {
    rss: number;
    heapTotal: number;
    heapUsed: number;
  };
}

export interface MemoryLeak {
  id: string;
  timestamp: number;
  type: 'heap' | 'rss' | 'external';
  rate: number; // bytes per second
  threshold: number;
  duration: number;
  snapshots: MemorySnapshot[];
}

export interface MemoryTrackerConfig {
  enableTracking: boolean;
  samplingInterval: number;
  historySize: number;
  leakDetectionThreshold: number; // bytes per second
  leakDetectionDuration: number; // minimum duration to consider a leak
  gcTriggerThreshold: number; // percentage of heap usage
  enableAutoGC: boolean;
  alertThresholds: {
    rss: number;
    heapUsed: number;
    heapTotal: number;
  };
}

export interface MemoryTrend {
  type: 'heap' | 'rss' | 'external';
  direction: 'increasing' | 'decreasing' | 'stable';
  rate: number; // bytes per second
  confidence: number; // 0-1
  projection: {
    nextHour: number;
    nextDay: number;
  };
}

export class MemoryTracker {
  private config: MemoryTrackerConfig;
  private snapshots: MemorySnapshot[] = [];
  private samplingTimer: Timer | null = null;
  private peaks = {
    rss: 0,
    heapTotal: 0,
    heapUsed: 0,
  };
  private eventHandlers = new Map<string, Set<Function>>();
  private detectedLeaks = new Map<string, MemoryLeak>();
  private gcTriggerCount = 0;
  private lastGCTime = 0;

  constructor(config: Partial<MemoryTrackerConfig> = {}) {
    this.config = {
      enableTracking: true,
      samplingInterval: 5000, // 5 seconds
      historySize: 1000,
      leakDetectionThreshold: 1024 * 1024, // 1MB per second
      leakDetectionDuration: 60000, // 1 minute
      gcTriggerThreshold: 85, // 85% heap usage
      enableAutoGC: false,
      alertThresholds: {
        rss: 100 * 1024 * 1024, // 100MB
        heapUsed: 50 * 1024 * 1024, // 50MB
        heapTotal: 75 * 1024 * 1024, // 75MB
      },
      ...config,
    };

    if (this.config.enableTracking) {
      this.startTracking();
    }

    this.setupGCMonitoring();
  }

  private startTracking(): void {
    this.captureSnapshot();

    this.samplingTimer = setInterval(() => {
      this.captureSnapshot();
      this.analyzeMemoryUsage();
      this.detectLeaks();
    }, this.config.samplingInterval);
  }

  private captureSnapshot(): MemorySnapshot {
    const memUsage = process.memoryUsage();
    const timestamp = Date.now();

    // Update peaks
    this.peaks.rss = Math.max(this.peaks.rss, memUsage.rss);
    this.peaks.heapTotal = Math.max(this.peaks.heapTotal, memUsage.heapTotal);
    this.peaks.heapUsed = Math.max(this.peaks.heapUsed, memUsage.heapUsed);

    const snapshot: MemorySnapshot = {
      timestamp,
      rss: memUsage.rss,
      heapTotal: memUsage.heapTotal,
      heapUsed: memUsage.heapUsed,
      external: memUsage.external,
      arrayBuffers: memUsage.arrayBuffers,
      peak: { ...this.peaks },
    };

    this.snapshots.push(snapshot);

    // Trim history if needed
    if (this.snapshots.length > this.config.historySize) {
      this.snapshots = this.snapshots.slice(-this.config.historySize);
    }

    this.emit('memorySnapshot', { snapshot });
    return snapshot;
  }

  private analyzeMemoryUsage(): void {
    if (this.snapshots.length < 2) return;

    const latest = this.snapshots[this.snapshots.length - 1];

    // Check alert thresholds
    this.checkAlertThresholds(latest);

    // Check GC trigger
    if (this.config.enableAutoGC) {
      this.checkGCTrigger(latest);
    }
  }

  private checkAlertThresholds(snapshot: MemorySnapshot): void {
    const { alertThresholds } = this.config;

    if (snapshot.rss > alertThresholds.rss) {
      this.emit('memoryAlert', {
        type: 'rss',
        value: snapshot.rss,
        threshold: alertThresholds.rss,
        percentage: (snapshot.rss / alertThresholds.rss) * 100,
      });
    }

    if (snapshot.heapUsed > alertThresholds.heapUsed) {
      this.emit('memoryAlert', {
        type: 'heapUsed',
        value: snapshot.heapUsed,
        threshold: alertThresholds.heapUsed,
        percentage: (snapshot.heapUsed / alertThresholds.heapUsed) * 100,
      });
    }

    if (snapshot.heapTotal > alertThresholds.heapTotal) {
      this.emit('memoryAlert', {
        type: 'heapTotal',
        value: snapshot.heapTotal,
        threshold: alertThresholds.heapTotal,
        percentage: (snapshot.heapTotal / alertThresholds.heapTotal) * 100,
      });
    }
  }

  private checkGCTrigger(snapshot: MemorySnapshot): void {
    const heapUsagePercent = (snapshot.heapUsed / snapshot.heapTotal) * 100;

    if (heapUsagePercent > this.config.gcTriggerThreshold) {
      const now = Date.now();

      // Avoid triggering GC too frequently
      if (now - this.lastGCTime > 30000) {
        // 30 seconds minimum between GC
        this.triggerGC();
        this.lastGCTime = now;
      }
    }
  }

  private detectLeaks(): void {
    if (this.snapshots.length < 10) return; // Need enough data

    const trends = this.calculateTrends();

    for (const trend of trends) {
      if (
        trend.direction === 'increasing' &&
        trend.rate > this.config.leakDetectionThreshold &&
        trend.confidence > 0.7
      ) {
        this.handlePotentialLeak(trend);
      }
    }
  }

  private handlePotentialLeak(trend: MemoryTrend): void {
    const leakId = `${trend.type}-${Date.now()}`;
    const now = Date.now();

    // Check if we already have a leak detection for this type
    const existingLeak = Array.from(this.detectedLeaks.values()).find(
      (leak) =>
        leak.type === trend.type &&
        now - leak.timestamp < this.config.leakDetectionDuration
    );

    if (existingLeak) {
      // Update existing leak
      existingLeak.rate = trend.rate;
      existingLeak.duration = now - existingLeak.timestamp;
      existingLeak.snapshots = this.snapshots.slice(-10); // Last 10 snapshots
    } else {
      // Create new leak detection
      const leak: MemoryLeak = {
        id: leakId,
        timestamp: now,
        type: trend.type,
        rate: trend.rate,
        threshold: this.config.leakDetectionThreshold,
        duration: 0,
        snapshots: this.snapshots.slice(-10),
      };

      this.detectedLeaks.set(leakId, leak);

      setTimeout(() => {
        this.confirmLeak(leakId);
      }, this.config.leakDetectionDuration);
    }
  }

  private confirmLeak(leakId: string): void {
    const leak = this.detectedLeaks.get(leakId);
    if (!leak) return;

    const currentTrends = this.calculateTrends();
    const currentTrend = currentTrends.find((t) => t.type === leak.type);

    if (
      currentTrend &&
      currentTrend.direction === 'increasing' &&
      currentTrend.rate > leak.threshold &&
      currentTrend.confidence > 0.7
    ) {
      // Confirmed leak
      leak.duration = Date.now() - leak.timestamp;
      this.emit('memoryLeak', { leak });
    } else {
      // False positive, remove
      this.detectedLeaks.delete(leakId);
    }
  }

  private calculateTrends(): MemoryTrend[] {
    if (this.snapshots.length < 5) return [];

    const recent = this.snapshots.slice(-10); // Last 10 snapshots
    const trends: MemoryTrend[] = [];

    // Calculate trend for each memory type
    const types = ['heap', 'rss', 'external'] as const;

    for (const type of types) {
      const values = recent.map((s) => {
        switch (type) {
          case 'heap':
            return s.heapUsed;
          case 'rss':
            return s.rss;
          case 'external':
            return s.external;
        }
      });

      const trend = this.calculateLinearTrend(
        recent.map((s) => s.timestamp),
        values
      );

      if (trend) {
        trends.push({
          type,
          direction:
            trend.slope > 1000
              ? 'increasing'
              : trend.slope < -1000
                ? 'decreasing'
                : 'stable',
          rate: trend.slope, // bytes per millisecond, will convert to per second
          confidence: trend.r2,
          projection: {
            nextHour: trend.slope * 3600000, // bytes in next hour
            nextDay: trend.slope * 86400000, // bytes in next day
          },
        });
      }
    }

    return trends;
  }

  private calculateLinearTrend(
    x: number[],
    y: number[]
  ): { slope: number; r2: number } | null {
    if (x.length < 2) return null;

    const n = x.length;
    const sumX = x.reduce((a, b) => a + b, 0);
    const sumY = y.reduce((a, b) => a + b, 0);
    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
    const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
    const sumYY = y.reduce((sum, yi) => sum + yi * yi, 0);

    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;

    // Calculate RÂ²
    const yMean = sumY / n;
    const totalSumSquares = y.reduce(
      (sum, yi) => sum + Math.pow(yi - yMean, 2),
      0
    );
    const residualSumSquares = y.reduce((sum, yi, i) => {
      const predicted = slope * x[i] + intercept;
      return sum + Math.pow(yi - predicted, 2);
    }, 0);

    const r2 = 1 - residualSumSquares / totalSumSquares;

    return { slope, r2 };
  }

  private setupGCMonitoring(): void {
    if (typeof global.gc === 'function') {
      // Track GC events if available
      const originalGC = global.gc;
      global.gc = (...args) => {
        const before = process.memoryUsage();
        const result = originalGC.apply(global, args);
        const after = process.memoryUsage();

        this.emit('gcTriggered', {
          type: 'manual',
          before,
          after,
          freed: {
            rss: before.rss - after.rss,
            heapUsed: before.heapUsed - after.heapUsed,
            heapTotal: before.heapTotal - after.heapTotal,
          },
        });

        return result;
      };
    }
  }

  public triggerGC(): boolean {
    if (typeof global.gc === 'function') {
      const before = process.memoryUsage();
      global.gc();
      const after = process.memoryUsage();

      this.gcTriggerCount++;

      this.emit('gcTriggered', {
        type: 'automatic',
        before,
        after,
        freed: {
          rss: before.rss - after.rss,
          heapUsed: before.heapUsed - after.heapUsed,
          heapTotal: before.heapTotal - after.heapTotal,
        },
      });

      return true;
    }
    return false;
  }

  public getCurrentSnapshot(): MemorySnapshot {
    return this.captureSnapshot();
  }

  public getSnapshots(count?: number): MemorySnapshot[] {
    if (count) {
      return this.snapshots.slice(-count);
    }
    return [...this.snapshots];
  }

  public getTrends(): MemoryTrend[] {
    return this.calculateTrends();
  }

  public getLeaks(): MemoryLeak[] {
    return Array.from(this.detectedLeaks.values());
  }

  public clearHistory(): void {
    this.snapshots = [];
    this.detectedLeaks.clear();
    this.peaks = { rss: 0, heapTotal: 0, heapUsed: 0 };
  }

  public getStatistics(): MemoryStatistics {
    if (this.snapshots.length === 0) {
      const current = process.memoryUsage();
      return {
        current,
        average: current,
        peak: current,
        trends: [],
        leakCount: 0,
        gcTriggers: this.gcTriggerCount,
        samplesCount: 0,
      };
    }

    const latest = this.snapshots[this.snapshots.length - 1];

    // Calculate averages
    const average = {
      rss:
        this.snapshots.reduce((sum, s) => sum + s.rss, 0) /
        this.snapshots.length,
      heapTotal:
        this.snapshots.reduce((sum, s) => sum + s.heapTotal, 0) /
        this.snapshots.length,
      heapUsed:
        this.snapshots.reduce((sum, s) => sum + s.heapUsed, 0) /
        this.snapshots.length,
      external:
        this.snapshots.reduce((sum, s) => sum + s.external, 0) /
        this.snapshots.length,
      arrayBuffers:
        this.snapshots.reduce((sum, s) => sum + s.arrayBuffers, 0) /
        this.snapshots.length,
    };

    return {
      current: {
        rss: latest.rss,
        heapTotal: latest.heapTotal,
        heapUsed: latest.heapUsed,
        external: latest.external,
        arrayBuffers: latest.arrayBuffers,
      },
      average,
      peak: {
        rss: this.peaks.rss,
        heapTotal: this.peaks.heapTotal,
        heapUsed: this.peaks.heapUsed,
        external: Math.max(...this.snapshots.map((s) => s.external)),
        arrayBuffers: Math.max(...this.snapshots.map((s) => s.arrayBuffers)),
      },
      trends: this.getTrends(),
      leakCount: this.detectedLeaks.size,
      gcTriggers: this.gcTriggerCount,
      samplesCount: this.snapshots.length,
    };
  }

  public updateConfig(newConfig: Partial<MemoryTrackerConfig>): void {
    this.config = { ...this.config, ...newConfig };

    // Restart tracking if interval changed
    if (newConfig.samplingInterval !== undefined && this.samplingTimer) {
      clearInterval(this.samplingTimer);
      this.startTracking();
    }

    // Enable/disable tracking
    if (newConfig.enableTracking !== undefined) {
      if (newConfig.enableTracking && !this.samplingTimer) {
        this.startTracking();
      } else if (!newConfig.enableTracking && this.samplingTimer) {
        clearInterval(this.samplingTimer);
        this.samplingTimer = null;
      }
    }
  }

  public getConfig(): MemoryTrackerConfig {
    return { ...this.config };
  }

  public destroy(): void {
    if (this.samplingTimer) {
      clearInterval(this.samplingTimer);
      this.samplingTimer = null;
    }

    this.clearHistory();
    this.eventHandlers.clear();
  }

  public on(event: string, handler: Function): void {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, new Set());
    }
    const handlers = this.eventHandlers.get(event);
    if (handlers != null) {
      handlers.add(handler);
    }
  }

  public off(event: string, handler: Function): void {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      handlers.delete(handler);
    }
  }

  private emit(event: string, data?: unknown): void {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      handlers.forEach((handler) => {
        try {
          handler(data);
        } catch (error) {
          console.error(
            `Error in memory tracker event handler for '${event}':`,
            error
          );
        }
      });
    }
  }
}

export interface MemoryStatistics {
  current: NodeJS.MemoryUsage;
  average: NodeJS.MemoryUsage;
  peak: NodeJS.MemoryUsage;
  trends: MemoryTrend[];
  leakCount: number;
  gcTriggers: number;
  samplesCount: number;
}
