import { RenderContext } from '../framework/UIFramework';
import { BaseComponent } from './BaseComponent';

export interface VirtualListItem {
  id: string | number;
  data: unknown;
  height?: number;
  selected?: boolean;
  disabled?: boolean;
  metadata?: Record<string, unknown>;
}

export interface VirtualListConfig {
  itemHeight: number;
  bufferSize: number;
  overscan: number;
  enableDynamicHeight: boolean;
  enableSelection: boolean;
  enableMultiSelection: boolean;
  enableSearch: boolean;
  scrollbarVisible: boolean;
  virtualizationThreshold: number;
}

export interface VirtualListState {
  scrollTop: number;
  viewportHeight: number;
  totalHeight: number;
  visibleStartIndex: number;
  visibleEndIndex: number;
  selectedIndices: Set<number>;
  focusedIndex: number;
  searchQuery: string;
  filteredIndices: number[];
}

export interface VirtualListRenderer<T = unknown> {
  renderItem: (
    item: VirtualListItem<T>,
    index: number,
    isSelected: boolean,
    isFocused: boolean
  ) => string;
  renderEmpty?: () => string;
  renderHeader?: () => string;
  renderFooter?: () => string;
  renderScrollbar?: (
    scrollTop: number,
    scrollHeight: number,
    viewportHeight: number
  ) => string;
  getItemHeight?: (item: VirtualListItem<T>, index: number) => number;
}

export class VirtualList<T = unknown> extends BaseComponent {
  private config: VirtualListConfig;
  private state: VirtualListState;
  private items: VirtualListItem<T>[] = [];
  private renderer: VirtualListRenderer<T>;
  private itemHeights = new Map<number, number>();
  private searchIndex = new Map<string, number[]>();
  private lastRenderTime = 0;
  private renderCache = new Map<string, string>();

  constructor(
    id: string,
    items: VirtualListItem<T>[] = [],
    renderer: VirtualListRenderer<T>,
    config: Partial<VirtualListConfig> = {}
  ) {
    super(id);

    this.config = {
      itemHeight: 1,
      bufferSize: 5,
      overscan: 2,
      enableDynamicHeight: false,
      enableSelection: true,
      enableMultiSelection: false,
      enableSearch: false,
      scrollbarVisible: true,
      virtualizationThreshold: 100,
      ...config,
    };

    this.state = {
      scrollTop: 0,
      viewportHeight: 10,
      totalHeight: 0,
      visibleStartIndex: 0,
      visibleEndIndex: 0,
      selectedIndices: new Set(),
      focusedIndex: 0,
      searchQuery: '',
      filteredIndices: [],
    };

    this.renderer = renderer;
    this.setItems(items);
  }

  public setItems(items: VirtualListItem<T>[]): void {
    this.items = [...items];
    this.rebuildSearchIndex();
    this.updateFilteredIndices();
    this.calculateTotalHeight();
    this.updateVisibleRange();
    this.markDirty();
  }

  public addItem(item: VirtualListItem<T>, index?: number): void {
    if (index !== undefined) {
      this.items.splice(index, 0, item);
    } else {
      this.items.push(item);
    }

    this.rebuildSearchIndex();
    this.updateFilteredIndices();
    this.calculateTotalHeight();
    this.updateVisibleRange();
    this.markDirty();
  }

  public removeItem(index: number): VirtualListItem<T> | null {
    if (index < 0 ?? index >= this.items.length) return null;

    const removed = this.items.splice(index, 1)[0];
    this.itemHeights.delete(index);

    // Update remaining item heights map
    const newHeights = new Map<number, number>();
    for (const [i, height] of this.itemHeights) {
      if (i > index) {
        newHeights.set(i - 1, height);
      } else {
        newHeights.set(i, height);
      }
    }
    this.itemHeights = newHeights;

    // Update selected indices
    const newSelected = new Set<number>();
    for (const selectedIndex of this.state.selectedIndices) {
      if (selectedIndex < index) {
        newSelected.add(selectedIndex);
      } else if (selectedIndex > index) {
        newSelected.add(selectedIndex - 1);
      }
    }
    this.state.selectedIndices = newSelected;

    // Update focused index
    if (this.state.focusedIndex >= index && this.state.focusedIndex > 0) {
      this.state.focusedIndex = Math.max(0, this.state.focusedIndex - 1);
    }

    this.rebuildSearchIndex();
    this.updateFilteredIndices();
    this.calculateTotalHeight();
    this.updateVisibleRange();
    this.markDirty();

    return removed;
  }

  public updateItem(index: number, item: Partial<VirtualListItem<T>>): boolean {
    if (index < 0 ?? index >= this.items.length) return false;

    this.items[index] = { ...this.items[index], ...item };

    // Clear cached height if it might have changed
    if (this.config.enableDynamicHeight) {
      this.itemHeights.delete(index);
    }

    this.rebuildSearchIndex();
    this.updateFilteredIndices();
    this.calculateTotalHeight();
    this.markDirty();

    return true;
  }

  public scrollTo(index: number): void {
    if (index < 0 ?? index >= this.getVisibleItemCount()) return;

    const actualIndex =
      this.state.filteredIndices.length > 0
        ? this.state.filteredIndices[index]
        : index;

    let targetScrollTop = 0;
    for (let i = 0; i < actualIndex; i++) {
      targetScrollTop += this.getItemHeight(i);
    }

    this.state.scrollTop = Math.max(
      0,
      Math.min(targetScrollTop, this.getMaxScrollTop())
    );
    this.updateVisibleRange();
    this.markDirty();
  }

  public scrollBy(delta: number): void {
    this.state.scrollTop = Math.max(
      0,
      Math.min(this.state.scrollTop + delta, this.getMaxScrollTop())
    );
    this.updateVisibleRange();
    this.markDirty();
  }

  public selectItem(index: number, toggle: boolean = false): void {
    if (
      !this.config.enableSelection ??
      index < 0 ??
      index >= this.getVisibleItemCount()
    )
      return;

    const actualIndex =
      this.state.filteredIndices.length > 0
        ? this.state.filteredIndices[index]
        : index;

    if (this.config.enableMultiSelection) {
      if (toggle && this.state.selectedIndices.has(actualIndex)) {
        this.state.selectedIndices.delete(actualIndex);
      } else {
        this.state.selectedIndices.add(actualIndex);
      }
    } else {
      this.state.selectedIndices.clear();
      this.state.selectedIndices.add(actualIndex);
    }

    this.markDirty();
  }

  public clearSelection(): void {
    this.state.selectedIndices.clear();
    this.markDirty();
  }

  public selectAll(): void {
    if (!this.config.enableMultiSelection) return;

    const visibleIndices =
      this.state.filteredIndices.length > 0
        ? this.state.filteredIndices
        : Array.from({ length: this.items.length }, (_, i) => i);

    this.state.selectedIndices = new Set(visibleIndices);
    this.markDirty();
  }

  public focusItem(index: number): void {
    if (index < 0 ?? index >= this.getVisibleItemCount()) return;

    this.state.focusedIndex = index;

    // Ensure focused item is visible
    const visibleStart = this.state.visibleStartIndex;
    const visibleEnd = this.state.visibleEndIndex;

    if (index < visibleStart) {
      this.scrollTo(index);
    } else if (index > visibleEnd) {
      this.scrollTo(index - (visibleEnd - visibleStart));
    }

    this.markDirty();
  }

  public search(query: string): void {
    if (!this.config.enableSearch) return;

    this.state.searchQuery = query.toLowerCase();
    this.updateFilteredIndices();
    this.state.focusedIndex = 0;
    this.state.scrollTop = 0;
    this.updateVisibleRange();
    this.markDirty();
  }

  public clearSearch(): void {
    this.state.searchQuery = '';
    this.updateFilteredIndices();
    this.markDirty();
  }

  private rebuildSearchIndex(): void {
    if (!this.config.enableSearch) return;

    this.searchIndex.clear();

    for (let i = 0; i < this.items.length; i++) {
      const item = this.items[i];
      const searchableText = this.getSearchableText(item).toLowerCase();

      // Simple word-based indexing
      const words = searchableText.split(/\s+/);
      for (const word of words) {
        if (!this.searchIndex.has(word)) {
          this.searchIndex.set(word, []);
        }
        const indices = this.searchIndex.get(word);
        if (indices != null) {
          indices.push(i);
        }
      }
    }
  }

  private getSearchableText(item: VirtualListItem<T>): string {
    // Override this method to customize how items are searched
    if (typeof item.data === 'string') {
      return item.data;
    } else if (typeof item.data === 'object' && item.data !== null) {
      return JSON.stringify(item.data);
    }
    return String(item.data);
  }

  private updateFilteredIndices(): void {
    if (!this.state.searchQuery) {
      this.state.filteredIndices = [];
      return;
    }

    const matchedIndices = new Set<number>();
    const queryWords = this.state.searchQuery.split(/\s+/);

    for (const word of queryWords) {
      for (const [indexWord, indices] of this.searchIndex) {
        if (indexWord.includes(word)) {
          indices.forEach((index) => matchedIndices.add(index));
        }
      }
    }

    this.state.filteredIndices = Array.from(matchedIndices).sort(
      (a, b) => a - b
    );
  }

  private calculateTotalHeight(): void {
    const itemCount = this.getVisibleItemCount();
    let totalHeight = 0;

    for (let i = 0; i < itemCount; i++) {
      const actualIndex =
        this.state.filteredIndices.length > 0
          ? this.state.filteredIndices[i]
          : i;
      totalHeight += this.getItemHeight(actualIndex);
    }

    this.state.totalHeight = totalHeight;
  }

  private getItemHeight(index: number): number {
    if (this.config.enableDynamicHeight) {
      const cachedHeight = this.itemHeights.get(index);
      if (cachedHeight !== undefined) {
        return cachedHeight;
      }

      if (this.renderer.getItemHeight && index < this.items.length) {
        const height = this.renderer.getItemHeight(this.items[index], index);
        this.itemHeights.set(index, height);
        return height;
      }
    }

    return this.items[index]?.height ?? this.config.itemHeight;
  }

  private updateVisibleRange(): void {
    const itemCount = this.getVisibleItemCount();
    if (itemCount === 0) {
      this.state.visibleStartIndex = 0;
      this.state.visibleEndIndex = 0;
      return;
    }

    // Use virtualization only if we have enough items
    if (itemCount < this.config.virtualizationThreshold) {
      this.state.visibleStartIndex = 0;
      this.state.visibleEndIndex = itemCount - 1;
      return;
    }

    let currentHeight = 0;
    let startIndex = 0;
    let endIndex = 0;

    // Find start index
    for (let i = 0; i < itemCount; i++) {
      const actualIndex =
        this.state.filteredIndices.length > 0
          ? this.state.filteredIndices[i]
          : i;
      const itemHeight = this.getItemHeight(actualIndex);

      if (currentHeight + itemHeight > this.state.scrollTop) {
        startIndex = Math.max(0, i - this.config.overscan);
        break;
      }
      currentHeight += itemHeight;
    }

    // Find end index
    currentHeight = 0;
    for (let i = startIndex; i < itemCount; i++) {
      const actualIndex =
        this.state.filteredIndices.length > 0
          ? this.state.filteredIndices[i]
          : i;
      const itemHeight = this.getItemHeight(actualIndex);
      currentHeight += itemHeight;

      if (
        currentHeight >=
        this.state.viewportHeight +
          this.config.overscan * this.config.itemHeight
      ) {
        endIndex = Math.min(itemCount - 1, i + this.config.overscan);
        break;
      }
      endIndex = i;
    }

    this.state.visibleStartIndex = startIndex;
    this.state.visibleEndIndex = endIndex;
  }

  private getVisibleItemCount(): number {
    return this.state.filteredIndices.length > 0
      ? this.state.filteredIndices.length
      : this.items.length;
  }

  private getMaxScrollTop(): number {
    return Math.max(0, this.state.totalHeight - this.state.viewportHeight);
  }

  private getCacheKey(
    index: number,
    isSelected: boolean,
    isFocused: boolean
  ): string {
    const actualIndex =
      this.state.filteredIndices.length > 0
        ? this.state.filteredIndices[index]
        : index;
    const item = this.items[actualIndex];
    return `${actualIndex}-${isSelected}-${isFocused}-${JSON.stringify(item)}`;
  }

  public render(context: RenderContext): string {
    const now = performance.now();
    this.state.viewportHeight =
      context.height -
      (this.renderer.renderHeader ? 1 : 0) -
      (this.renderer.renderFooter ? 1 : 0);

    // Update visible range based on current viewport
    this.updateVisibleRange();

    const lines: string[] = [];

    // Render header
    if (this.renderer.renderHeader) {
      lines.push(this.renderer.renderHeader());
    }

    const itemCount = this.getVisibleItemCount();

    if (itemCount === 0) {
      // Render empty state
      if (this.renderer.renderEmpty) {
        const emptyContent = this.renderer.renderEmpty();
        const emptyLines = emptyContent.split('\n');
        const startPadding = Math.max(
          0,
          Math.floor((this.state.viewportHeight - emptyLines.length) / 2)
        );

        for (let i = 0; i < startPadding; i++) {
          lines.push('');
        }
        lines.push(...emptyLines);
      }
    } else {
      // Calculate offset for virtualization
      let offsetHeight = 0;
      for (let i = 0; i < this.state.visibleStartIndex; i++) {
        const actualIndex =
          this.state.filteredIndices.length > 0
            ? this.state.filteredIndices[i]
            : i;
        offsetHeight += this.getItemHeight(actualIndex);
      }

      // Add empty lines for offset (virtualization spacer)
      if (
        offsetHeight > 0 &&
        itemCount >= this.config.virtualizationThreshold
      ) {
        const offsetLines = Math.floor(offsetHeight / this.config.itemHeight);
        for (let i = 0; i < offsetLines; i++) {
          lines.push('');
        }
      }

      // Render visible items
      for (
        let i = this.state.visibleStartIndex;
        i <= this.state.visibleEndIndex && i < itemCount;
        i++
      ) {
        const actualIndex =
          this.state.filteredIndices.length > 0
            ? this.state.filteredIndices[i]
            : i;

        if (actualIndex >= this.items.length) continue;

        const item = this.items[actualIndex];
        const isSelected = this.state.selectedIndices.has(actualIndex);
        const isFocused = i === this.state.focusedIndex;

        // Check cache
        const cacheKey = this.getCacheKey(i, isSelected, isFocused);
        let renderedItem = this.renderCache.get(cacheKey);

        if (renderedItem == null) {
          renderedItem = this.renderer.renderItem(
            item,
            actualIndex,
            isSelected,
            isFocused
          );
          this.renderCache.set(cacheKey, renderedItem);

          // Limit cache size
          if (this.renderCache.size > 1000) {
            const firstKey = this.renderCache.keys().next().value;
            this.renderCache.delete(firstKey);
          }
        }

        const itemLines = renderedItem.split('\n');
        lines.push(...itemLines);
      }
    }

    // Render scrollbar
    if (
      this.config.scrollbarVisible &&
      this.state.totalHeight > this.state.viewportHeight
    ) {
      if (this.renderer.renderScrollbar) {
        const scrollbarContent = this.renderer.renderScrollbar(
          this.state.scrollTop,
          this.state.totalHeight,
          this.state.viewportHeight
        );

        // Merge scrollbar with existing content
        const scrollbarLines = scrollbarContent.split('\n');
        for (
          let i = 0;
          i < Math.min(lines.length, scrollbarLines.length);
          i++
        ) {
          if (scrollbarLines[i]) {
            lines[i] = lines[i] + scrollbarLines[i];
          }
        }
      }
    }

    // Render footer
    if (this.renderer.renderFooter) {
      lines.push(this.renderer.renderFooter());
    }

    // Trim to viewport height
    const maxLines = context.height;
    if (lines.length > maxLines) {
      lines.splice(maxLines);
    }

    // Pad to viewport height
    while (lines.length < maxLines) {
      lines.push('');
    }

    this.lastRenderTime = performance.now() - now;
    return lines.join('\n');
  }

  // Public API for getting state and statistics
  public getState(): VirtualListState {
    return { ...this.state };
  }

  public getItems(): VirtualListItem<T>[] {
    return [...this.items];
  }

  public getVisibleItems(): VirtualListItem<T>[] {
    const result: VirtualListItem<T>[] = [];
    for (
      let i = this.state.visibleStartIndex;
      i <= this.state.visibleEndIndex;
      i++
    ) {
      const actualIndex =
        this.state.filteredIndices.length > 0
          ? this.state.filteredIndices[i]
          : i;
      if (actualIndex < this.items.length) {
        result.push(this.items[actualIndex]);
      }
    }
    return result;
  }

  public getSelectedItems(): VirtualListItem<T>[] {
    return Array.from(this.state.selectedIndices)
      .filter((index) => index < this.items.length)
      .map((index) => this.items[index]);
  }

  public getFocusedItem(): VirtualListItem<T> | null {
    const actualIndex =
      this.state.filteredIndices.length > 0
        ? this.state.filteredIndices[this.state.focusedIndex]
        : this.state.focusedIndex;
    return actualIndex < this.items.length ? this.items[actualIndex] : null;
  }

  public getPerformanceMetrics(): VirtualListMetrics {
    return {
      totalItems: this.items.length,
      visibleItems:
        this.state.visibleEndIndex - this.state.visibleStartIndex + 1,
      filteredItems: this.state.filteredIndices.length ?? this.items.length,
      selectedItems: this.state.selectedIndices.size,
      virtualizationActive:
        this.getVisibleItemCount() >= this.config.virtualizationThreshold,
      lastRenderTime: this.lastRenderTime,
      cacheSize: this.renderCache.size,
      scrollPosition: {
        top: this.state.scrollTop,
        max: this.getMaxScrollTop(),
        percentage:
          this.getMaxScrollTop() > 0
            ? (this.state.scrollTop / this.getMaxScrollTop()) * 100
            : 0,
      },
    };
  }

  public updateConfig(newConfig: Partial<VirtualListConfig>): void {
    this.config = { ...this.config, ...newConfig };

    // Clear cache if rendering might have changed
    if (
      newConfig.itemHeight !== undefined ??
      newConfig.enableDynamicHeight !== undefined
    ) {
      this.renderCache.clear();
      this.itemHeights.clear();
    }

    this.calculateTotalHeight();
    this.updateVisibleRange();
    this.markDirty();
  }

  public getConfig(): VirtualListConfig {
    return { ...this.config };
  }
}

export interface VirtualListMetrics {
  totalItems: number;
  visibleItems: number;
  filteredItems: number;
  selectedItems: number;
  virtualizationActive: boolean;
  lastRenderTime: number;
  cacheSize: number;
  scrollPosition: {
    top: number;
    max: number;
    percentage: number;
  };
}
