import { BaseComponent } from '../components/BaseComponent';
import { RenderContext } from '../framework/UIFramework';
import { DebugManager, ComponentDebugInfo } from './DebugManager';

export interface DebugOverlayConfig {
  position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
  size: { width: number; height: number };
  opacity: number;
  autoHide: boolean;
  autoHideDelay: number;
  resizable: boolean;
  movable: boolean;
  theme: 'dark' | 'light' | 'auto';
}

export interface DebugPanel {
  id: string;
  title: string;
  hotkey: string;
  render: (width: number, height: number) => string[];
  enabled: boolean;
  icon?: string;
}

export class DebugOverlay extends BaseComponent {
  private debugManager: DebugManager;
  private config: DebugOverlayConfig;
  private panels = new Map<string, DebugPanel>();
  private selectedPanelId = 'logs';
  private scrollOffset = 0;
  private isResizing = false;
  private isMoving = false;
  private lastInteraction = Date.now();
  private autoHideTimer: Timer | null = null;

  constructor(
    debugManager: DebugManager,
    config: Partial<DebugOverlayConfig> = {}
  ) {
    super('debug-overlay');

    this.debugManager = debugManager;
    this.config = {
      position: 'bottom-right',
      size: { width: 80, height: 25 },
      opacity: 0.9,
      autoHide: false,
      autoHideDelay: 5000,
      resizable: true,
      movable: true,
      theme: 'dark',
      ...config,
    };

    this.setupDefaultPanels();
    this.setupEventHandlers();
    this.startAutoHideTimer();
  }

  private setupDefaultPanels(): void {
    // Logs panel
    this.addPanel({
      id: 'logs',
      title: 'Logs',
      hotkey: '1',
      enabled: true,
      icon: 'ðŸ“‹',
      render: (width, height) => this.renderLogsPanel(width, height),
    });

    // Metrics panel
    this.addPanel({
      id: 'metrics',
      title: 'Metrics',
      hotkey: '2',
      enabled: true,
      icon: 'ðŸ“Š',
      render: (width, height) => this.renderMetricsPanel(width, height),
    });

    // Components panel
    this.addPanel({
      id: 'components',
      title: 'Components',
      hotkey: '3',
      enabled: true,
      icon: 'ðŸ§©',
      render: (width, height) => this.renderComponentsPanel(width, height),
    });

    // Performance panel
    this.addPanel({
      id: 'performance',
      title: 'Performance',
      hotkey: '4',
      enabled: true,
      icon: 'âš¡',
      render: (width, height) => this.renderPerformancePanel(width, height),
    });

    // Console panel
    this.addPanel({
      id: 'console',
      title: 'Console',
      hotkey: '5',
      enabled: true,
      icon: 'ðŸ’»',
      render: (width, height) => this.renderConsolePanel(width, height),
    });
  }

  private setupEventHandlers(): void {
    this.debugManager.on('logAdded', () => {
      if (this.selectedPanelId === 'logs') {
        this.markDirty();
      }
    });

    this.debugManager.on('metricsUpdated', () => {
      if (this.selectedPanelId === 'metrics') {
        this.markDirty();
      }
    });

    this.debugManager.on('componentTreeUpdated', () => {
      if (this.selectedPanelId === 'components') {
        this.markDirty();
      }
    });
  }

  private startAutoHideTimer(): void {
    if (!this.config.autoHide) return;

    if (this.autoHideTimer) {
      clearTimeout(this.autoHideTimer);
    }

    this.autoHideTimer = setTimeout(() => {
      if (Date.now() - this.lastInteraction > this.config.autoHideDelay) {
        this.hide();
      }
    }, this.config.autoHideDelay);
  }

  public addPanel(panel: DebugPanel): void {
    this.panels.set(panel.id, panel);
  }

  public removePanel(id: string): boolean {
    return this.panels.delete(id);
  }

  public selectPanel(id: string): boolean {
    if (this.panels.has(id)) {
      this.selectedPanelId = id;
      this.scrollOffset = 0;
      this.recordInteraction();
      this.markDirty();
      return true;
    }
    return false;
  }

  public handleKeyPress(key: string): boolean {
    this.recordInteraction();

    // Panel selection hotkeys
    for (const [id, panel] of this.panels) {
      if (panel.hotkey === key && panel.enabled) {
        this.selectPanel(id);
        return true;
      }
    }

    // Navigation keys
    switch (key) {
      case 'ArrowUp':
        this.scrollUp();
        return true;
      case 'ArrowDown':
        this.scrollDown();
        return true;
      case 'PageUp':
        this.scrollOffset = Math.max(0, this.scrollOffset - 10);
        this.markDirty();
        return true;
      case 'PageDown':
        this.scrollOffset += 10;
        this.markDirty();
        return true;
      case 'Home':
        this.scrollOffset = 0;
        this.markDirty();
        return true;
      case 'c':
        if (this.selectedPanelId === 'logs') {
          this.debugManager.clearLogs();
          return true;
        }
        break;
      case 'e':
        this.exportCurrentPanel();
        return true;
    }

    return false;
  }

  public handleMouseEvent(
    x: number,
    y: number,
    button: 'left' | 'right' | 'wheel',
    delta?: number
  ): boolean {
    this.recordInteraction();

    const overlayBounds = this.getOverlayBounds();
    if (!this.isPointInOverlay(x, y, overlayBounds)) {
      return false;
    }

    if (button === 'wheel' && delta != null) {
      if (delta > 0) {
        this.scrollDown();
      } else {
        this.scrollUp();
      }
      return true;
    }

    if (button === 'left') {
      // Check if clicking on panel tabs
      const tabY = overlayBounds.y + 2; // Tab row
      if (y === tabY) {
        const tabIndex = Math.floor((x - overlayBounds.x) / 12);
        const panels = Array.from(this.panels.values()).filter(
          (p) => p.enabled
        );
        if (tabIndex >= 0 && tabIndex < panels.length) {
          this.selectPanel(panels[tabIndex].id);
          return true;
        }
      }
    }

    return true; // Consume event even if not handled specifically
  }

  private scrollUp(): void {
    this.scrollOffset = Math.max(0, this.scrollOffset - 1);
    this.markDirty();
  }

  private scrollDown(): void {
    this.scrollOffset += 1;
    this.markDirty();
  }

  private recordInteraction(): void {
    this.lastInteraction = Date.now();
    this.startAutoHideTimer();
  }

  private exportCurrentPanel(): void {
    const panel = this.panels.get(this.selectedPanelId);
    if (!panel) return;

    const content = panel.render(
      this.config.size.width - 4,
      this.config.size.height - 6
    );
    const _exportData = {
      panel: panel.title,
      timestamp: new Date().toISOString(),
      content: content.join('\n'),
    };

    this.debugManager.log(
      'info',
      'Debug',
      `Exported ${panel.title} panel data`
    );
    // In a real implementation, this could save to a file or copy to clipboard
  }

  private getOverlayBounds(): {
    x: number;
    y: number;
    width: number;
    height: number;
  } {
    // This would need to be calculated based on terminal size and position
    // For now, return a placeholder
    return {
      x: 0,
      y: 0,
      width: this.config.size.width,
      height: this.config.size.height,
    };
  }

  private isPointInOverlay(
    x: number,
    y: number,
    bounds: ReturnType<typeof this.getOverlayBounds>
  ): boolean {
    return (
      x >= bounds.x &&
      x < bounds.x + bounds.width &&
      y >= bounds.y &&
      y < bounds.y + bounds.height
    );
  }

  private renderLogsPanel(width: number, height: number): string[] {
    const logs = this.debugManager.getLogs();
    const visibleLogs = logs.slice(
      this.scrollOffset,
      this.scrollOffset + height
    );
    const lines: string[] = [];

    for (const log of visibleLogs) {
      const timestamp = new Date(log.timestamp).toLocaleTimeString();
      const levelIcon = this.getLevelIcon(log.level);
      const line = `${levelIcon} ${timestamp} [${log.category}] ${log.message}`;
      lines.push(this.truncateLine(line, width));
    }

    // Fill remaining space
    while (lines.length < height) {
      lines.push('');
    }

    return lines;
  }

  private renderMetricsPanel(width: number, height: number): string[] {
    const metrics = this.debugManager.getMetrics();
    const lines: string[] = [];

    lines.push(`ðŸ“Š Performance Metrics`);
    lines.push('');
    lines.push(`â±ï¸  Render Time: ${metrics.renderTime.toFixed(2)}ms`);
    lines.push(`ðŸ§© Components: ${metrics.componentCount}`);
    lines.push(`ðŸŽ¯ Events: ${metrics.eventCount}`);
    lines.push(
      `ðŸ’¾ Memory: ${(metrics.memoryUsage / 1024 / 1024).toFixed(2)}MB`
    );
    lines.push(`ðŸ“ˆ FPS: ${metrics.fps.toFixed(1)}`);
    lines.push(
      `ðŸ• Last Update: ${new Date(metrics.lastUpdate).toLocaleTimeString()}`
    );

    // System info
    if (typeof process !== 'undefined') {
      lines.push('');
      lines.push('ðŸ–¥ï¸  System Info');
      lines.push(`Node.js: ${process.version}`);
      lines.push(`Platform: ${process.platform}`);
      lines.push(`Uptime: ${Math.floor(process.uptime())}s`);
    }

    // Fill remaining space
    while (lines.length < height) {
      lines.push('');
    }

    return lines;
  }

  private renderComponentsPanel(width: number, height: number): string[] {
    const tree = this.debugManager.getComponentTree();
    const lines: string[] = [];

    if (tree) {
      lines.push('ðŸ§© Component Tree');
      lines.push('');
      this.renderComponentTreeRecursive(tree, lines, 0, width);
    } else {
      lines.push('No component tree available');
    }

    // Apply scroll offset
    const visibleLines = lines.slice(
      this.scrollOffset,
      this.scrollOffset + height
    );

    // Fill remaining space
    while (visibleLines.length < height) {
      visibleLines.push('');
    }

    return visibleLines;
  }

  private renderComponentTreeRecursive(
    component: ComponentDebugInfo,
    lines: string[],
    depth: number,
    width: number
  ): void {
    const indent = '  '.repeat(depth);
    const prefix = depth > 0 ? 'â”œâ”€ ' : '';
    const line = `${indent}${prefix}${component.type} (${component.id})`;
    const statusIcon = component.state === 'mounted' ? 'âœ…' : 'â¸ï¸';
    const fullLine = `${statusIcon} ${line}`;

    lines.push(this.truncateLine(fullLine, width));

    for (const child of component.children) {
      this.renderComponentTreeRecursive(child, lines, depth + 1, width);
    }
  }

  private renderPerformancePanel(width: number, height: number): string[] {
    const lines: string[] = [];
    const perfLogs = this.debugManager
      .getLogs()
      .filter((log) => log.category === 'Profiler')
      .slice(this.scrollOffset, this.scrollOffset + height);

    lines.push('âš¡ Performance Profiling');
    lines.push('');

    if (perfLogs.length === 0) {
      lines.push('No performance data available');
      lines.push('Enable profiling in debug config');
    } else {
      for (const log of perfLogs) {
        const timestamp = new Date(log.timestamp).toLocaleTimeString();
        const line = `${timestamp} ${log.message}`;
        lines.push(this.truncateLine(line, width));
      }
    }

    // Fill remaining space
    while (lines.length < height) {
      lines.push('');
    }

    return lines;
  }

  private renderConsolePanel(width: number, height: number): string[] {
    const lines: string[] = [];

    lines.push('ðŸ’» Debug Console');
    lines.push('');
    lines.push('Available commands:');
    lines.push('  clear - Clear logs');
    lines.push('  export - Export current panel');
    lines.push('  metrics - Show current metrics');
    lines.push('  gc - Trigger garbage collection');
    lines.push('');
    lines.push('Hotkeys:');
    lines.push('  1-5 - Switch panels');
    lines.push('  â†‘â†“ - Scroll');
    lines.push('  PgUp/PgDn - Page scroll');
    lines.push('  Home - Go to top');
    lines.push('  c - Clear (in logs panel)');
    lines.push('  e - Export current panel');

    // Fill remaining space
    while (lines.length < height) {
      lines.push('');
    }

    return lines;
  }

  private getLevelIcon(level: string): string {
    switch (level) {
      case 'debug':
        return 'ðŸ”';
      case 'info':
        return 'â„¹ï¸';
      case 'warn':
        return 'âš ï¸';
      case 'error':
        return 'âŒ';
      default:
        return 'â€¢';
    }
  }

  private truncateLine(line: string, maxWidth: number): string {
    if (line.length <= maxWidth) {
      return line.padEnd(maxWidth, ' ');
    }
    return line.slice(0, maxWidth - 3) + '...';
  }

  private renderTabs(width: number): string {
    const enabledPanels = Array.from(this.panels.values()).filter(
      (p) => p.enabled
    );
    const tabs: string[] = [];

    for (const panel of enabledPanels) {
      const isSelected = panel.id === this.selectedPanelId;
      const icon = panel.icon ?? '';
      const title = panel.title;
      const hotkey = `(${panel.hotkey})`;

      let tab = `${icon} ${title} ${hotkey}`;
      if (isSelected) {
        tab = `[${tab}]`;
      } else {
        tab = ` ${tab} `;
      }

      tabs.push(tab);
    }

    const tabLine = tabs.join('â”‚');
    return this.truncateLine(tabLine, width);
  }

  private renderBorder(width: number, height: number, title: string): string[] {
    const lines: string[] = [];

    // Top border with title
    const titleLine = title ? ` ${title} ` : '';
    const remainingWidth = width - titleLine.length - 2;
    const leftPadding = Math.floor(remainingWidth / 2);
    const rightPadding = remainingWidth - leftPadding;

    lines.push(
      `â”Œ${'â”€'.repeat(leftPadding)}${titleLine}${'â”€'.repeat(rightPadding)}â”`
    );

    // Tab row
    const tabsLine = this.renderTabs(width - 2);
    lines.push(`â”‚${tabsLine}â”‚`);
    lines.push(`â”œ${'â”€'.repeat(width - 2)}â”¤`);

    return lines;
  }

  public render(context: RenderContext): string {
    if (!this.debugManager.isEnabled() ?? !this.debugManager.isDebugVisible()) {
      return '';
    }

    const lines: string[] = [];
    const selectedPanel = this.panels.get(this.selectedPanelId);

    if (!selectedPanel) {
      return '';
    }

    // Calculate overlay dimensions and position
    const overlayWidth = Math.min(this.config.size.width, context.width);
    const overlayHeight = Math.min(this.config.size.height, context.height);
    const contentHeight = overlayHeight - 4; // Account for borders and tabs

    // Render border and tabs
    const borderLines = this.renderBorder(
      overlayWidth,
      overlayHeight,
      'Debug Panel'
    );
    lines.push(...borderLines);

    // Render panel content
    const contentLines = selectedPanel.render(overlayWidth - 2, contentHeight);

    for (const line of contentLines) {
      lines.push(`â”‚${line}â”‚`);
    }

    // Bottom border
    lines.push(`â””${'â”€'.repeat(overlayWidth - 2)}â”˜`);

    // Position overlay based on config
    const { x, y } = this.calculatePosition(
      context.width,
      context.height,
      overlayWidth,
      overlayHeight
    );

    // Apply positioning using ANSI escape codes
    const positionedLines = lines.map((line, index) => {
      return `\x1b[${y + index + 1};${x + 1}H${line}`;
    });

    return positionedLines.join('');
  }

  private calculatePosition(
    termWidth: number,
    termHeight: number,
    overlayWidth: number,
    overlayHeight: number
  ): { x: number; y: number } {
    switch (this.config.position) {
      case 'top-left':
        return { x: 0, y: 0 };
      case 'top-right':
        return { x: termWidth - overlayWidth, y: 0 };
      case 'bottom-left':
        return { x: 0, y: termHeight - overlayHeight };
      case 'bottom-right':
      default:
        return { x: termWidth - overlayWidth, y: termHeight - overlayHeight };
    }
  }

  public show(): void {
    this.debugManager.enable();
    this.recordInteraction();
    this.markDirty();
  }

  public hide(): void {
    // Don't disable debug manager, just hide overlay
    this.recordInteraction();
    this.markDirty();
  }

  public toggle(): void {
    if (this.debugManager.isDebugVisible()) {
      this.hide();
    } else {
      this.show();
    }
  }

  public updateConfig(newConfig: Partial<DebugOverlayConfig>): void {
    this.config = { ...this.config, ...newConfig };
    this.markDirty();
  }

  public getConfig(): DebugOverlayConfig {
    return { ...this.config };
  }
}
