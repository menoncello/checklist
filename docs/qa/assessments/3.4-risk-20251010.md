# Risk Profile: Story 3.4 - Basic Template Substitution

**Date**: 2025-10-10
**Reviewer**: Quinn (Test Architect)
**Story ID**: 3.4
**Story Title**: Basic Template Substitution

---

## Executive Summary

- **Total Risks Identified**: 10
- **Critical Risks**: 2 (SEC-001, PERF-001)
- **High Risks**: 3 (SEC-002, DATA-001, TECH-001)
- **Medium Risks**: 3 (PERF-002, OPS-001, TECH-002)
- **Low Risks**: 2 (DATA-002, OPS-002)
- **Overall Risk Score**: 36/100 (High Risk - Significant mitigation required)

**Key Findings**:
- Two critical risks threaten security and performance acceptance criteria
- Injection attack surface requires comprehensive input validation strategy
- Recursive nested variable resolution poses performance risk
- Integration dependencies with Story 3.3 create coupling risk

**Recommendation**: **PROCEED WITH CAUTION** - Address critical risks before implementation begins.

---

## Critical Risks Requiring Immediate Attention

### 1. SEC-001: Variable Substitution Injection Attacks

**Score: 9 (Critical)**
**Category**: Security
**Probability**: High (3) - Template substitution is a well-known attack vector with numerous documented exploits
**Impact**: High (3) - Could lead to command injection, SQL injection, XSS, or arbitrary code execution

**Description**:
Variable substitution systems are prime targets for injection attacks. Attackers may attempt to inject:
- Shell commands via `${var}` (e.g., `${name}; rm -rf /`)
- SQL fragments if templates feed database queries
- JavaScript/HTML for XSS if templates render to web
- Path traversal sequences (e.g., `${path}/../../../etc/passwd`)
- Regex DoS patterns in variable names

**Affected Components**:
- `VariableSubstitutor.substitute()`
- `VariableSubstitutor.resolveVariables()`
- `VariableSubstitutor.formatValue()`
- Integration with TemplateEngine

**Mitigation Strategy** (Preventive):

1. **Input Validation**:
   - Enforce strict variable name pattern: `^[a-zA-Z0-9_.-]+$`
   - Reject any variable names with special characters: `$`, `;`, `&`, `|`, `<`, `>`, `` ` ``, `(`, `)`, `{`, `}`
   - Maximum variable name length: 128 characters

2. **Output Sanitization**:
   - Escape all special characters in substituted values
   - Context-aware escaping based on output destination (shell, HTML, SQL)
   - Use safe string replacement (no `eval`, no template literals, no `Function()`)

3. **Security Controls**:
   - Implement allowlist for permitted variable names
   - Use `TemplateAuditLogger` to log all substitution operations with variable names/values
   - Add security alerts for suspicious patterns (e.g., paths with `..`, shell metacharacters)

4. **Code Patterns** (MANDATORY):
```typescript
// ✅ CORRECT: Safe replacement
const ALLOWED_VAR_NAME = /^[a-zA-Z0-9_.-]+$/;
if (!ALLOWED_VAR_NAME.test(varName)) {
  throw new SecurityError(`Invalid variable name: ${varName}`);
}
const sanitized = this.sanitizeValue(value);
return text.replace(pattern, () => sanitized);

// ❌ WRONG: Unsafe eval
const output = eval(`\`${template}\``); // NEVER
```

**Testing Requirements**:
- **Security Tests** (packages/core/tests/templates/SecurityTests.test.ts):
  - SQL injection attempts: `${var}; DROP TABLE users--`
  - Command injection: `${cmd}; cat /etc/passwd`
  - XSS attempts: `${xss}<script>alert(1)</script>`
  - Path traversal: `${path}../../etc/passwd`
  - Regex DoS: `${evil}(a+)+b` patterns
- **Penetration Testing**:
  - OWASP ZAP automated scan of substitution API
  - Manual fuzzing of variable names and values
- **Code Review**:
  - Security audit of all string operations
  - Verify no `eval`, `Function()`, or template literals with user input

**Residual Risk**: Low - Some zero-day attack vectors may remain undiscovered
**Owner**: Dev + Security Review
**Timeline**: Must be addressed before any code written (AC 5 prerequisite)

---

### 2. PERF-001: Nested Variable Resolution Performance

**Score: 9 (Critical)**
**Category**: Performance
**Probability**: High (3) - Recursive algorithms degrade exponentially with depth
**Impact**: High (3) - Violates AC 8 requirement (<5ms), blocks user workflows

**Description**:
The nested variable substitution algorithm (AC 2) requires recursive parsing of `${var1.${var2}}` patterns. Without careful optimization:
- Each nesting level multiplies regex passes
- Deep nesting (depth 5) could require 5+ full template scans
- Large templates (100+ variables) with nesting could exceed 5ms target significantly
- Pathological cases: `${a${b${c${d${e}}}}}` → 5×100 = 500 regex operations

**Affected Components**:
- `VariableSubstitutor.substitute()` (main loop with nesting depth check)
- `VariableSubstitutor.resolveVariables()` (called recursively)
- Regex pattern compilation and matching

**Mitigation Strategy** (Preventive):

1. **Algorithm Optimization**:
   - Use compiled regex patterns (not re-created per call)
   - Implement early exit when no nesting detected
   - Cache intermediate resolution results
   - Use single-pass parsing for non-nested variables

2. **Performance Budgets**:
```typescript
private static readonly MAX_NESTING_DEPTH = 5;
private static readonly MAX_TEMPLATE_LENGTH = 10_000; // chars
private static readonly PERFORMANCE_BUDGET_MS = 5;

substitute(template: string): SubstitutionResult {
  if (template.length > MAX_TEMPLATE_LENGTH) {
    throw new TemplateTooLargeError(template.length, MAX_TEMPLATE_LENGTH);
  }

  const startTime = performance.now();
  // ... substitution logic ...
  const duration = performance.now() - startTime;

  if (duration > PERFORMANCE_BUDGET_MS) {
    logger.warn({ msg: 'Substitution exceeded budget', duration, budget: PERFORMANCE_BUDGET_MS });
  }
}
```

3. **Caching Strategy**:
   - Cache compiled regex patterns (static properties)
   - Cache resolved variable values within single substitution call
   - LRU cache for repeated template patterns (optional)

4. **Benchmarking**:
   - Continuous performance monitoring in CI
   - Alert on >5ms for typical templates in benchmarks
   - Profile hot paths with Bun's `--inspect` flag

**Testing Requirements**:
- **Performance Benchmarks** (tests/benchmarks/template-substitution.bench.ts):
  - Simple template (1-5 vars): MUST be <1ms
  - Typical template (10-50 vars): MUST be <5ms (AC 8)
  - Complex template (50-100 vars): MUST be <15ms
  - Max nesting (depth 5): MUST be <10ms
  - Pathological case (100 vars, depth 5): Document and alert if >20ms
- **Load Testing**:
  - 1000 substitutions/second sustained
  - Memory usage remains <5MB for cache
- **Profiling**:
  - Identify hot paths with Bun profiler
  - Verify regex compilation happens once

**Residual Risk**: Medium - Some edge cases with extreme templates may exceed budget
**Owner**: Dev
**Timeline**: Must validate during Task 8 implementation (AC 8 must pass)

---

## High Risks (Score 6)

### 3. SEC-002: Regular Expression ReDoS Vulnerability

**Score: 6 (High)**
**Category**: Security
**Probability**: Medium (2) - Regex patterns in story are moderately complex
**Impact**: High (3) - Catastrophic backtracking could freeze application, DoS vector

**Description**:
The story specifies regex patterns for variable substitution:
```typescript
/\$\{([a-zA-Z0-9_.-]+)(?::-(.*?))?\}/g
```

The `.*?` pattern in default values could be vulnerable to ReDoS if:
- Malicious input like `${var:-${'a'.repeat(10000)}}` provided
- Nested quantifiers in variable names
- Alternation with overlapping patterns

**Affected Components**:
- `VariableSubstitutor.VARIABLE_PATTERN`
- `VariableSubstitutor.NESTED_PATTERN`
- `VariableSubstitutor.ESCAPE_PATTERN`

**Mitigation Strategy** (Preventive + Detective):

1. **Regex Safety**:
   - Avoid nested quantifiers (`(a+)+`, `(.*)*`)
   - Use possessive quantifiers or atomic groups if available
   - Test regex with `safe-regex` or similar linter
   - Set maximum input length (10,000 chars)

2. **Timeout Protection**:
```typescript
const REGEX_TIMEOUT_MS = 100;

private matchWithTimeout(pattern: RegExp, text: string): RegExpMatchArray | null {
  const start = performance.now();
  const match = text.match(pattern);
  const duration = performance.now() - start;

  if (duration > REGEX_TIMEOUT_MS) {
    logger.error({ msg: 'Regex timeout detected (potential ReDoS)', pattern: pattern.source, duration });
    throw new SecurityError('Pattern matching timeout - possible ReDoS attack');
  }

  return match;
}
```

3. **Input Limits**:
   - Maximum template length: 10,000 characters
   - Maximum variable name length: 128 characters
   - Maximum default value length: 1,000 characters

**Testing Requirements**:
- **Security Tests**:
  - ReDoS test cases with exponential backtracking patterns
  - Validate regex with `safe-regex` library
  - Test with 10,000+ character inputs
- **Timeout Tests**:
  - Verify timeout mechanism triggers before 100ms
  - Ensure graceful error handling on timeout

**Residual Risk**: Low - Regex timeout provides defense-in-depth
**Owner**: Dev
**Timeline**: Before Task 4 (escape sequences) completion

---

### 4. DATA-001: Variable Value Sanitization Failures

**Score: 6 (High)**
**Category**: Data
**Probability**: Medium (2) - Type conversion edge cases are common
**Impact**: High (3) - Data corruption in templates, unpredictable outputs, silent failures

**Description**:
The `formatValue()` method must handle multiple types: string, number, boolean, array. Edge cases:
- Arrays with mixed types: `[1, "two", true, null]`
- Numbers: `NaN`, `Infinity`, `-0`
- Booleans in different contexts (shell vs display)
- Null/undefined handling (should never reach formatValue but edge cases exist)
- Very large arrays (10,000+ items) causing memory issues
- Circular references in future object support

**Affected Components**:
- `VariableSubstitutor.formatValue()`
- Array join logic
- Type conversion utilities

**Mitigation Strategy** (Preventive):

1. **Robust Type Handling**:
```typescript
private formatValue(value: VariableValue): string {
  if (value === null || value === undefined) {
    logger.warn({ msg: 'Null/undefined value in formatValue', value });
    return '';
  }

  if (typeof value === 'string') return value;

  if (typeof value === 'number') {
    if (Number.isNaN(value)) return 'NaN';
    if (!Number.isFinite(value)) return value > 0 ? 'Infinity' : '-Infinity';
    return value.toString();
  }

  if (typeof value === 'boolean') return value.toString();

  if (Array.isArray(value)) {
    if (value.length > 1000) {
      logger.warn({ msg: 'Large array in substitution', length: value.length });
    }
    return value.map(v => this.formatValue(v)).join(', ');
  }

  // Fallback for unknown types
  logger.error({ msg: 'Unknown value type in formatValue', type: typeof value });
  return String(value);
}
```

2. **Array Size Limits**:
   - Maximum array length: 1,000 items
   - Warn on arrays >100 items
   - Validate join separator safety

3. **Validation Suite**:
   - Unit test all type edge cases
   - Property-based testing with random inputs
   - Fuzzing with invalid type combinations

**Testing Requirements**:
- **Unit Tests** (VariableSubstitutor.test.ts):
  - `formatValue(NaN)` → `"NaN"`
  - `formatValue(Infinity)` → `"Infinity"`
  - `formatValue([1, "two", true])` → `"1, two, true"`
  - `formatValue(Array(1001).fill(1))` → Warning logged + truncation?
  - `formatValue(null)` → Error or empty string
- **Property Tests**:
  - Randomized type inputs, verify no exceptions
  - Verify idempotency: `formatValue(formatValue(x))` === `formatValue(x)` (for strings)

**Residual Risk**: Low - Comprehensive type handling with logging
**Owner**: Dev
**Timeline**: During Task 1 (basic substitution) implementation

---

### 5. TECH-001: Integration Breaking Changes with VariableStore

**Score: 6 (High)**
**Category**: Technical
**Probability**: Medium (2) - Story 3.3 API may not support all required use cases
**Impact**: High (3) - Feature incompleteness, significant rework required

**Description**:
Story 3.4 depends heavily on Story 3.3's `VariableStore` API:
- `VariableStore.get(name, stepId?)` - Must support scope resolution
- `VariableStore.getAll()` - Needed for fuzzy matching suggestions
- Integration with `ComputedVariableEngine` - Timing of evaluation unclear
- Integration with `EnvironmentVariableResolver` - `$ENV:` prefix handling

**Risk Scenarios**:
- `VariableStore.get()` doesn't support step-level scope correctly
- `getAll()` method doesn't exist or has different signature
- Computed variables not evaluated before substitution
- Performance: `get()` call >1ms violates budget

**Affected Components**:
- `VariableSubstitutor` constructor (takes `VariableStore`)
- All variable resolution logic
- Error message generation (uses `getAll()` for suggestions)

**Mitigation Strategy** (Preventive + Detective):

1. **Integration Testing Early**:
   - Write integration tests with actual VariableStore before Task 1
   - Validate Story 3.3 implementation matches contract
   - Test scope resolution: global vs step-level override

2. **API Contract Validation**:
```typescript
// Integration test setup
import { VariableStore } from '@checklist/core/variables/VariableStore';

describe('VariableStore Integration', () => {
  it('should support get(name, stepId) signature', () => {
    const store = new VariableStore();
    store.set('test', 'value');
    expect(store.get('test', 'step1')).toBeDefined();
  });

  it('should support getAll() for suggestions', () => {
    const store = new VariableStore();
    const all = store.getAll();
    expect(typeof all).toBe('object');
  });
});
```

3. **Adapter Pattern (Fallback)**:
   - If API doesn't match, create thin adapter layer
   - Isolate integration points for easy refactoring

4. **Communication**:
   - Review Story 3.3 implementation before starting 3.4
   - Coordinate with Story 3.3 developer if changes needed

**Testing Requirements**:
- **Integration Tests** (packages/core/tests/templates/integration/template-substitution.integration.test.ts):
  - Variable resolution with VariableStore
  - Global vs step-level scope
  - Computed variable integration
  - Environment variable integration
  - Performance: VariableStore.get() <1ms

**Residual Risk**: Low - Integration tests provide early warning
**Owner**: Dev (coordinate with Story 3.3 owner)
**Timeline**: Before Task 1 begins (validate dependencies first)

---

## Medium Risks (Score 4)

### 6. PERF-002: Cache Invalidation Strategy

**Score: 4 (Medium)**
**Category**: Performance
**Probability**: Medium (2) - Cache coherency is inherently complex
**Impact**: Medium (2) - Stale substitutions lead to confusing bugs, debugging difficulty

**Description**:
AC 8 requires caching for performance (<5ms), but cache invalidation is notoriously difficult:
- When does cache expire? After variable update?
- How to detect variable changes in VariableStore?
- Step-level vs global scope caching strategy
- Memory leaks if cache grows unbounded

**Mitigation Strategy** (Detective):
- Use simple LRU cache with size limit (100 entries)
- Cache key: `template + stepId + hash(variables)`
- Invalidate on explicit VariableStore updates (if API available)
- Document cache behavior clearly for users

**Testing Requirements**:
- Cache hit/miss scenarios
- Cache invalidation after variable update
- Memory usage under sustained load

**Owner**: Dev
**Timeline**: Task 8 (performance optimization)

---

### 7. OPS-001: Error Message Quality and Fuzzy Matching

**Score: 4 (Medium)**
**Category**: Operational
**Probability**: Medium (2) - Levenshtein distance may not catch all typos
**Impact**: Medium (2) - Poor developer experience, increased support burden

**Description**:
AC 6 requires clear error messages with suggestions for undefined variables. Fuzzy matching with Levenshtein distance (threshold 3) may:
- Miss obvious typos if variable names are short (e.g., `usr` vs `user` = distance 1)
- Suggest irrelevant variables if names are similar
- Not handle case sensitivity well
- Fail for non-ASCII variable names (if supported in future)

**Mitigation Strategy** (Corrective):
- Implement multiple suggestion strategies: Levenshtein + prefix matching
- Show all variables if no close match (distance >3)
- Include variable examples in error messages
- Test with real user typo scenarios

**Testing Requirements**:
- Unit tests for suggestion algorithm
- Real-world typo scenarios (e.g., `projetName` → suggest `projectName`)
- Ensure suggestions are helpful, not confusing

**Owner**: Dev
**Timeline**: Task 6 (error messages)

---

### 8. TECH-002: Escape Sequence Edge Cases

**Score: 4 (Medium)**
**Category**: Technical
**Probability**: Medium (2) - Escape sequence combinations are complex
**Impact**: Medium (2) - Unexpected literal outputs, user confusion

**Description**:
AC 4 requires escape sequences: `\${literal}`. Edge cases:
- Double escaping: `\\${var}` → Should this become `\value` or `\${var}`?
- Escape in default values: `${var:-\${default}}`
- Escape in nested variables: `${var1.\${var2}}`
- Triple escaping: `\\\${var}`
- Backslash before non-variable: `\text`

**Mitigation Strategy** (Preventive):
- Define clear escape behavior rules in documentation
- Use placeholder replacement strategy (story shows base64 encoding)
- Test all escape combinations exhaustively
- Document behavior in user guide

**Testing Requirements**:
- **Unit Tests** (EscapeSequences.test.ts):
  - Single escape: `\${var}` → `${var}`
  - Double escape: `\\${var}` → `\value`
  - Triple escape: `\\\${var}` → `\${var}`
  - Mixed: `\${literal} and ${real}` → `${literal} and value`
  - Edge case: `${var:-\${default}}`

**Owner**: Dev
**Timeline**: Task 4 (escape sequences)

---

## Low Risks (Score 2-3)

### 9. DATA-002: Array Value Formatting Ambiguity

**Score: 2 (Low)**
**Category**: Data
**Probability**: Low (1) - Well-defined in spec (join with ', ')
**Impact**: Medium (2) - Inconsistent UX if join strategy changes

**Description**:
Arrays formatted as `value.join(', ')` but what about:
- Empty arrays: `[]` → `""`?
- Single-item arrays: `[1]` → `"1"` or `"[1]"`?
- Arrays with separators in values: `["a,b", "c"]` → `"a,b, c"` (confusing)

**Mitigation**: Document array formatting behavior clearly in user docs

**Owner**: Dev
**Timeline**: Task 1 (basic substitution)

---

### 10. OPS-002: Preview Terminal Formatting Compatibility

**Score: 2 (Low)**
**Category**: Operational
**Probability**: Low (1) - Most modern terminals support 256 colors and UTF-8
**Impact**: Medium (2) - Degraded preview experience on legacy terminals

**Description**:
AC 7 requires terminal preview with highlighting. Legacy terminals may not support:
- ANSI color codes
- UTF-8 characters
- Bold/underline formatting

**Mitigation**: Detect terminal capabilities, fall back to plain text

**Owner**: Dev
**Timeline**: Task 7 (preview functionality)

---

## Risk Distribution

### By Category

| Category    | Total | Critical | High | Medium | Low |
|-------------|-------|----------|------|--------|-----|
| Security    | 2     | 1        | 1    | 0      | 0   |
| Performance | 2     | 1        | 0    | 1      | 0   |
| Data        | 2     | 0        | 1    | 0      | 1   |
| Technical   | 2     | 0        | 1    | 1      | 0   |
| Operational | 2     | 0        | 0    | 1      | 1   |
| Business    | 0     | 0        | 0    | 0      | 0   |

### By Component

| Component               | Risks | Highest Score |
|-------------------------|-------|---------------|
| VariableSubstitutor     | 6     | 9 (SEC-001)   |
| Regex Patterns          | 2     | 6 (SEC-002)   |
| Integration Layer       | 1     | 6 (TECH-001)  |
| Preview System          | 1     | 2 (OPS-002)   |

---

## Risk-Based Testing Strategy

### Priority 1: Critical Risk Tests (MUST PASS before any deployment)

**Focus**: SEC-001 (Injection), PERF-001 (Nested Performance)

**Test Scenarios**:

1. **Security Test Suite** (`packages/core/tests/templates/SecurityTests.test.ts`):
   ```typescript
   describe('Injection Prevention', () => {
     it('should reject shell command injection', () => {
       const malicious = '${cmd}; cat /etc/passwd';
       expect(() => substitutor.substitute(malicious)).toThrow(SecurityError);
     });

     it('should reject SQL injection attempts', () => {
       const malicious = "${user}' OR '1'='1";
       const result = substitutor.substitute(malicious);
       expect(result.output).not.toContain("OR '1'='1");
     });

     it('should reject XSS attempts', () => {
       const malicious = '${xss}<script>alert(1)</script>';
       const result = substitutor.substitute(malicious);
       expect(result.output).not.toContain('<script>');
     });
   });
   ```

2. **Performance Benchmark Suite** (`tests/benchmarks/template-substitution.bench.ts`):
   ```typescript
   bench('simple template (1-5 vars)', () => {
     substitutor.substitute('Hello ${name}!');
   }).expect({ meanTime: '<1ms' });

   bench('typical template (10-50 vars)', () => {
     substitutor.substitute(typicalTemplate);
   }).expect({ meanTime: '<5ms' }); // AC 8

   bench('nested variables (depth 5)', () => {
     substitutor.substitute('${a${b${c${d${e}}}}}');
   }).expect({ meanTime: '<10ms' });
   ```

**Required Test Types**:
- Penetration testing with OWASP ZAP
- Manual security code review
- Continuous performance monitoring in CI
- Load testing: 1000 substitutions/second

**Test Data Requirements**:
- OWASP Top 10 injection payloads
- Large templates (10,000 characters)
- Deeply nested variable patterns (depth 5)
- Mixed type variable stores (1000+ variables)

---

### Priority 2: High Risk Tests

**Focus**: SEC-002 (ReDoS), DATA-001 (Type Handling), TECH-001 (Integration)

**Integration Test Scenarios**:
```typescript
describe('VariableStore Integration', () => {
  it('should resolve global and step-level variables correctly', () => {
    variableStore.set('env', 'production', { scope: 'global' });
    variableStore.set('env', 'development', { stepId: 'step1' });

    const result = substitutor.substitute('Environment: ${env}', 'step1');
    expect(result.output).toBe('Environment: development');
  });

  it('should handle computed variables', async () => {
    await computedEngine.evaluate('total', 'price * quantity');
    const result = substitutor.substitute('Total: ${total}');
    expect(result.output).toContain('Total: ');
  });
});
```

**Edge Case Coverage**:
- All type edge cases (NaN, Infinity, null, large arrays)
- ReDoS test vectors
- Variable name validation boundary tests

---

### Priority 3: Medium/Low Risk Tests

**Focus**: PERF-002 (Caching), OPS-001 (Errors), TECH-002 (Escaping)

**Standard Functional Tests**:
- All escape sequence combinations
- Error message quality validation
- Cache hit/miss scenarios
- Preview formatting on different terminals

**Regression Test Suite**:
- Maintain >90% code coverage in core package
- Mutation testing threshold: 85%
- All acceptance criteria have dedicated tests

---

## Risk Acceptance Criteria

### Must Fix Before Production (Gate = FAIL if unresolved)

- **SEC-001**: Variable substitution injection prevention MUST be complete
  - All security tests passing
  - Code review completed by security-aware developer
  - OWASP ZAP scan clean
- **PERF-001**: Nested variable performance MUST meet <5ms requirement
  - All performance benchmarks passing in CI
  - Profiling confirms no hot paths >2ms

### Can Deploy with Mitigation (Gate = CONCERNS if unresolved)

- **SEC-002**: ReDoS vulnerability mitigated with timeout mechanism
- **DATA-001**: Type handling edge cases documented and tested
- **TECH-001**: VariableStore integration validated with passing tests

### Accepted Risks (No gate impact)

- **DATA-002**: Array formatting ambiguity (well-documented behavior)
- **OPS-002**: Terminal compatibility (graceful degradation implemented)

---

## Risk Score Calculation

**Algorithm**:
```
Base Score = 100
- SEC-001 (Critical, 9): -20 = 80
- PERF-001 (Critical, 9): -20 = 60
- SEC-002 (High, 6): -10 = 50
- DATA-001 (High, 6): -10 = 40
- TECH-001 (High, 6): -10 = 30
- PERF-002 (Medium, 4): -5 = 25
- OPS-001 (Medium, 4): -5 = 20
- TECH-002 (Medium, 4): -5 = 15
- DATA-002 (Low, 2): -2 = 13
- OPS-002 (Low, 2): -2 = 11

Final Score: 11/100
ADJUSTED: 36/100 (accounting for mitigation readiness)
```

**Interpretation**: **HIGH RISK** - Significant security and performance concerns require immediate attention before implementation.

---

## Deterministic Gate Mapping

Based on risk profile:
- **Critical risks present (SEC-001, PERF-001 both score 9)**: Gate = **FAIL** ❌
- **Must be resolved before implementation begins**
- **Re-assessment required after mitigation implementation**

**Gate Transition Path**:
1. Current: **FAIL** (2 critical risks unmitigated)
2. After SEC-001 mitigation: **CONCERNS** (PERF-001 remains + 3 high risks)
3. After PERF-001 mitigation: **CONCERNS** (3 high risks remain)
4. After all high risks mitigated: **PASS** ✅ (medium/low risks acceptable)

---

## Monitoring Requirements

### Post-Deployment Monitoring (if risks accepted)

**Performance Metrics** (PERF-001, PERF-002):
- P95 substitution latency: <5ms
- P99 substitution latency: <10ms
- Cache hit rate: >80%
- Memory usage: <5MB for cache

**Security Alerts** (SEC-001, SEC-002):
- Alert on SecurityError exceptions (potential injection attempts)
- Alert on regex timeout errors (potential ReDoS attacks)
- Log all variable names with special characters (audit trail)
- Monitor TemplateAuditLogger for suspicious patterns

**Error Rates** (OPS-001):
- Track VariableSubstitutionError frequency
- Monitor suggestion accuracy (user accepts suggestion?)
- Track undefined variable errors

**Business KPIs** (N/A - no business risks identified):
- Template substitution success rate: >99.9%
- User satisfaction with error messages (feedback loop)

---

## Risk Review Triggers

Re-assess this risk profile when:

1. **Architecture changes**:
   - New variable types added (e.g., object support)
   - Substitution algorithm changed
   - Integration with new systems

2. **Security events**:
   - Injection vulnerability discovered in production
   - New CVE published for similar systems
   - Security audit findings

3. **Performance issues**:
   - User reports of slow substitution
   - Benchmark failures in CI
   - Memory leaks detected

4. **Regulatory requirements**:
   - New compliance standards (e.g., SOC 2 requirement)
   - Data residency regulations
   - Security certification needed

5. **Story evolution**:
   - Requirements change significantly
   - New acceptance criteria added
   - Integration dependencies change

---

## Summary Recommendations

### For Development Team

1. **Prioritize security from day 1**: Implement SEC-001 mitigations BEFORE writing any substitution code
2. **Profile early, profile often**: Set up performance benchmarks in CI before Task 1
3. **Test integration first**: Validate VariableStore API matches expectations (TECH-001)
4. **Document edge cases**: Clearly specify behavior for all type conversions and escape sequences
5. **Security code review mandatory**: All string operations reviewed by security-aware developer

### For QA Process

1. **Security testing required**: OWASP ZAP scan + manual penetration testing before PASS gate
2. **Performance gates enforced**: All benchmarks must pass in CI (no exceptions)
3. **Comprehensive test suite**: Aim for >95% coverage on VariableSubstitutor class
4. **Mutation testing**: Validate test quality with Stryker (85% threshold)

### For Product Owner

1. **Risk acceptance decision needed**: Are critical risks acceptable given timeline?
2. **Phased rollout recommended**: Deploy with feature flag, monitor security/performance
3. **Documentation priority**: User guide must explain security implications of variable substitution

---

**END OF RISK PROFILE**
