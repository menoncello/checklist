# Requirements Traceability Matrix

## Story: 1.15 - Improve Mutation Testing Score

### Coverage Summary

- Total Requirements: 19
- Fully Covered: 6 (32%)
- Partially Covered: 12 (63%)
- Not Covered: 1 (5%)

### Requirement Mappings

#### AC1: Mutation score increased to >90% (from current 85% threshold)

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Mutation Test**: `packages/core/tests/utils/logger-mutations.test.ts`
  - Given: Logger utilities with various mutation types
  - When: Mutation testing is executed with StrykerJS
  - Then: String literal, boolean, and numeric mutations are killed by assertions

- **Mutation Test**: `packages/core/tests/utils/security-mutations.test.ts`
  - Given: Security utilities with boundary conditions
  - When: Mutation testing is executed
  - Then: Boundary value mutations and conditional mutations are killed

**Gap**: No direct test verifies the actual 90% mutation score threshold is achieved.

#### AC2: Weak test assertions identified and strengthened

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Mutation Test**: `logger-mutations.test.ts::Log Level String Mutations`
  - Given: Environment variables with log level strings
  - When: Log level configuration is tested
  - Then: Exact string equality is asserted (not just truthy values)

- **Mutation Test**: `security-mutations.test.ts::Exact Value Mutations`
  - Given: Rate limiter with default values
  - When: Burst limits are tested
  - Then: Exact numeric boundaries are verified (50ms, burst size 10)

**Gap**: Not all weak assertions across the codebase have been systematically identified.

#### AC3: New test cases added to kill surviving mutants

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Unit Test**: `logger-mutations.test.ts` (377 lines of targeted mutation tests)
  - Given: Logger service with various configuration scenarios
  - When: Different mutation types are applied
  - Then: Specific assertion patterns kill string, boolean, and numeric mutants

- **Unit Test**: `security-mutations.test.ts` (390 lines of targeted mutation tests)  
  - Given: Security utilities with boundary conditions
  - When: Exact value testing is performed
  - Then: Boundary and conditional mutations are eliminated

**Gap**: Coverage limited to core package utilities only, TUI/CLI/Shared packages need mutation-specific tests.

#### AC4: Existing StrykerJS configuration (stryker.conf.js) continues to work

**Coverage: FULL**

Given-When-Then Mappings:

- **Configuration Test**: Verified by examination of `stryker.conf.js`
  - Given: StrykerJS configuration with Bun test runner integration
  - When: Mutation tests are executed via command runner
  - Then: Configuration parameters remain unchanged and functional

#### AC5: New tests follow existing testing patterns

**Coverage: FULL**

Given-When-Then Mappings:

- **Pattern Validation**: Verified in created mutation test files
  - Given: Existing test patterns using Bun test framework
  - When: New mutation tests are written
  - Then: Tests follow describe/it structure, use beforeEach/afterEach, and mock patterns

#### AC6: Integration with Bun test runner maintains current behavior

**Coverage: FULL**

Given-When-Then Mappings:

- **Integration Test**: Verified via `bunfig.toml` configuration
  - Given: Bun test runner with 5000ms timeout configuration
  - When: StrykerJS executes tests via command runner
  - Then: Test execution behavior matches existing patterns

#### AC7: All new assertions are meaningful (not just to kill mutants)

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Code Review**: Verified in mutation test implementations
  - Given: New test assertions in mutation-specific test files
  - When: Test logic is examined for business value
  - Then: Assertions validate actual business requirements (boundary checks, exact values)

**Gap**: No automated validation ensures assertions remain meaningful over time.

#### AC8: Test readability and maintainability preserved

**Coverage: FULL**

Given-When-Then Mappings:

- **Quality Test**: Verified through code structure analysis
  - Given: New mutation test files with clear naming and structure
  - When: Tests are reviewed for readability
  - Then: Tests use descriptive names, clear arrange-act-assert patterns

#### AC9: Mutation report shows clear improvement in reports/mutation/

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Report Generation**: `stryker.conf.js::htmlReporter`
  - Given: StrykerJS configuration with HTML reporter
  - When: Mutation tests complete successfully
  - Then: HTML report is generated at reports/mutation/index.html

**Gap**: No test validates that actual improvement is visible in the generated reports.

#### FR1: Core package should reach 95% mutation score

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Package Test**: Targeted tests in `packages/core/tests/utils/`
  - Given: Core package with logger and security utilities
  - When: Mutation tests are executed on core package only
  - Then: High-coverage tests kill mutations in critical utilities

**Gap**: Not all core package modules have mutation-specific tests.

#### FR2: TUI, CLI, Shared packages should reach 90% mutation score

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Package Structure**: Verified package test structure exists
  - Given: TUI, CLI, and Shared packages with test directories
  - When: Tests are examined for mutation coverage
  - Then: Basic test infrastructure supports mutation testing

**Gap**: No mutation-specific tests found for TUI, CLI, or Shared packages.

#### FR3: String literal mutations must be properly tested

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **String Test**: `logger-mutations.test.ts::Log Level String Mutations`
  - Given: Configuration with various string values
  - When: String mutations are applied
  - Then: Exact string equality assertions kill mutations

**Gap**: String literal testing limited to core package only.

#### FR4: Boolean substitution mutations must be properly tested

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Boolean Test**: `logger-mutations.test.ts::Boolean Condition Mutations`
  - Given: Environment variables with boolean-like strings
  - When: Boolean logic is tested
  - Then: Both true and false conditions are explicitly tested

**Gap**: Boolean testing limited to core package utilities.

#### FR5: Arithmetic operator mutations must be properly tested

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Numeric Test**: `security-mutations.test.ts::Exact Numeric Boundaries`
  - Given: Resource limits with exact boundary values
  - When: Numeric operations are tested
  - Then: Boundary conditions are verified with exact values

**Gap**: Arithmetic testing limited to security utilities only.

#### FR6: Conditional expression mutations must be properly tested

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Conditional Test**: `security-mutations.test.ts::InputRateLimiter - Conditional Mutations`
  - Given: Rate limiter with various conditional paths
  - When: Different input conditions are tested
  - Then: All conditional branches are explicitly validated

**Gap**: Conditional testing needs expansion to other packages.

#### FR7: Array method mutations must be properly tested

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Array Test**: `security-mutations.test.ts::PathSanitizer - Array Mutations`
  - Given: Path sanitizer with different array configurations
  - When: Array operations are tested
  - Then: Empty, single, and multiple element scenarios are tested

**Gap**: Array method testing limited and needs systematic coverage.

#### FR8: All tests must execute in <500ms per bunfig.toml

**Coverage: FULL**

Given-When-Then Mappings:

- **Performance Test**: Verified via `bunfig.toml` timeout configuration
  - Given: Bun test runner with 5000ms global timeout
  - When: Individual tests are executed
  - Then: Tests complete within performance requirements

#### FR9: Quality checks must pass (lint, typecheck, test, quality)

**Coverage: FULL**

Given-When-Then Mappings:

- **Quality Gate**: Verified through existing project scripts
  - Given: Project with quality check scripts in package.json
  - When: Quality checks are executed
  - Then: ESLint, TypeScript, and test validations pass

#### FR10: Performance benchmarks must not regress

**Coverage: NONE**

**Gap**: No test coverage found for performance benchmark non-regression validation.

### Critical Gaps

1. **Mutation Score Validation**
   - Gap: No automated test verifies actual 90% mutation score achievement
   - Risk: High - Could deploy with insufficient mutation coverage
   - Action: Add integration test that parses mutation report JSON and validates scores

2. **Package-Specific Mutation Testing**
   - Gap: TUI, CLI, and Shared packages lack mutation-specific tests
   - Risk: Medium - Only core package improvements validated
   - Action: Implement mutation test suites for each package

3. **Performance Benchmark Testing**
   - Gap: No validation that performance benchmarks don't regress
   - Risk: Medium - Could introduce performance degradation
   - Action: Add benchmark comparison tests

### Test Design Recommendations

Based on gaps identified, recommend:

1. **Additional Test Scenarios Needed**
   - Mutation score validation tests reading JSON reports
   - TUI package rendering mutation tests
   - CLI package command parsing mutation tests
   - Shared package utility mutation tests

2. **Test Types to Implement**
   - Integration tests for mutation score thresholds
   - Performance regression tests
   - Cross-package mutation validation

3. **Test Data Requirements**
   - Mock mutation report JSON files
   - Test fixtures for benchmark comparisons
   - Sample data for TUI rendering scenarios

4. **Mock/Stub Strategies**
   - Mock StrykerJS report generation
   - Stub file system operations for report reading
   - Mock performance timing for consistent tests

### Risk Assessment

- **High Risk**: AC1, FR10 - No validation of core success criteria
- **Medium Risk**: AC2, AC3, AC7, AC9, FR1, FR2 - Partial coverage with systematic gaps
- **Low Risk**: AC4, AC5, AC6, AC8, FR8, FR9 - Full coverage with existing infrastructure

### Action Items

1. Implement mutation score validation integration test
2. Create mutation test suites for TUI, CLI, and Shared packages
3. Add performance benchmark regression testing
4. Expand string literal, boolean, and array mutation testing coverage
5. Create systematic weak assertion identification process