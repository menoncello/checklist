# Story 3.4 Testing Guide

**Story:** 3.4 - Basic Template Substitution
**Epic:** 3 - Templates & Security
**Test Location:** `packages/core/tests/templates/`
**Coverage Target:** 90%+ (Core package)

## Testing Strategy Overview

### Test Pyramid

```
        /\
       /  \      8 Performance Benchmarks
      /____\
     /      \    15 Integration Tests
    /        \
   /__________\  80+ Unit Tests
```

### Coverage Targets

| Component | Target | Priority |
|-----------|--------|----------|
| VariableSubstitutor | 95%+ | CRITICAL |
| SubstitutionPreview | 90%+ | HIGH |
| Error Handling | 100% | CRITICAL |
| Security Validation | 100% | CRITICAL |

## Test File Structure

```
packages/core/tests/templates/
├── VariableSubstitutor.test.ts          # Main substitution tests
├── SubstitutionPreview.test.ts          # Preview functionality
├── NestedSubstitution.test.ts           # Nested variable tests
├── DefaultValues.test.ts                # Default value handling
├── EscapeSequences.test.ts              # Escape sequence tests
├── SecurityTests.test.ts                # Injection prevention
└── integration/
    └── template-substitution.integration.test.ts

tests/benchmarks/
└── template-substitution.bench.ts       # Performance benchmarks
```

---

## Unit Tests

### 1. VariableSubstitutor.test.ts

**Purpose:** Test core substitution functionality

```typescript
import { describe, test, expect, beforeEach } from 'bun:test';
import { VariableSubstitutor } from '../../src/templates/VariableSubstitutor';
import { VariableStore } from '../../src/variables/VariableStore';
import {
  VariableSubstitutionError,
  NestingDepthExceededError,
  SecurityError,
} from '../../src/templates/errors';

describe('VariableSubstitutor', () => {
  let variableStore: VariableStore;
  let substitutor: VariableSubstitutor;

  beforeEach(() => {
    variableStore = new VariableStore(':memory:');
    substitutor = new VariableSubstitutor(variableStore);
  });

  describe('Basic Substitution', () => {
    test('should substitute single variable', () => {
      variableStore.set('name', 'Alice');

      const result = substitutor.substitute('Hello ${name}!');

      expect(result.output).toBe('Hello Alice!');
      expect(result.variablesUsed).toEqual(['name']);
      expect(result.errors).toHaveLength(0);
      expect(result.metadata.variableCount).toBe(1);
    });

    test('should substitute multiple variables', () => {
      variableStore.set('firstName', 'Alice');
      variableStore.set('lastName', 'Smith');

      const result = substitutor.substitute(
        'Name: ${firstName} ${lastName}'
      );

      expect(result.output).toBe('Name: Alice Smith');
      expect(result.variablesUsed).toEqual(['firstName', 'lastName']);
    });

    test('should handle template without variables', () => {
      const result = substitutor.substitute('No variables here');

      expect(result.output).toBe('No variables here');
      expect(result.variablesUsed).toHaveLength(0);
      expect(result.metadata.duration).toBe(0); // Early exit
    });

    test('should preserve non-matching patterns', () => {
      const result = substitutor.substitute('Price: $100 USD');

      expect(result.output).toBe('Price: $100 USD');
    });
  });

  describe('Variable Types', () => {
    test('should format string variables', () => {
      variableStore.set('text', 'Hello World');

      const result = substitutor.substitute('Text: ${text}');

      expect(result.output).toBe('Text: Hello World');
    });

    test('should format number variables', () => {
      variableStore.set('count', 42);

      const result = substitutor.substitute('Count: ${count}');

      expect(result.output).toBe('Count: 42');
    });

    test('should format boolean variables', () => {
      variableStore.set('enabled', true);

      const result = substitutor.substitute('Enabled: ${enabled}');

      expect(result.output).toBe('Enabled: true');
    });

    test('should format array variables', () => {
      variableStore.set('tags', ['tag1', 'tag2', 'tag3']);

      const result = substitutor.substitute('Tags: ${tags}');

      expect(result.output).toBe('Tags: tag1, tag2, tag3');
    });
  });

  describe('Undefined Variables', () => {
    test('should report undefined variable error', () => {
      const result = substitutor.substitute('Hello ${name}!');

      expect(result.errors).toHaveLength(1);
      expect(result.errors[0].variableName).toBe('name');
      expect(result.errors[0].message).toContain('not defined');
      expect(result.output).toBe('Hello ${name}!'); // Preserved
    });

    test('should suggest similar variable names', () => {
      variableStore.set('projectName', 'MyApp');

      const result = substitutor.substitute('Name: ${projectNmae}'); // Typo

      expect(result.errors).toHaveLength(1);
      expect(result.errors[0].suggestions).toContain('projectName');
    });

    test('should allow undefined variables when configured', () => {
      const permissiveSubstitutor = new VariableSubstitutor(variableStore, {
        allowUndefinedVariables: true,
      });

      const result = permissiveSubstitutor.substitute('Hello ${name}!');

      expect(result.output).toBe('Hello !'); // Empty replacement
      expect(result.errors).toHaveLength(0);
    });
  });

  describe('Step-Level Scope', () => {
    test('should use step-level variables', () => {
      variableStore.set('env', 'production'); // Global
      variableStore.set('env', 'development', 'step-1'); // Step-level

      const result = substitutor.substitute('Env: ${env}', 'step-1');

      expect(result.output).toBe('Env: development'); // Step overrides global
    });

    test('should fall back to global scope', () => {
      variableStore.set('project', 'MyApp'); // Global only

      const result = substitutor.substitute('Project: ${project}', 'step-1');

      expect(result.output).toBe('Project: MyApp');
    });
  });

  describe('Performance', () => {
    test('should complete substitution within time budget', () => {
      // Create typical template with 20 variables
      for (let i = 0; i < 20; i++) {
        variableStore.set(`var${i}`, `value${i}`);
      }

      const template = Array.from(
        { length: 20 },
        (_, i) => `\${var${i}}`
      ).join(' ');

      const result = substitutor.substitute(template);

      expect(result.metadata.duration).toBeLessThan(5); // <5ms target
      expect(result.output).toContain('value0');
      expect(result.output).toContain('value19');
    });

    test('should handle large templates efficiently', () => {
      for (let i = 0; i < 100; i++) {
        variableStore.set(`var${i}`, `value${i}`);
      }

      const template = Array.from(
        { length: 100 },
        (_, i) => `\${var${i}}`
      ).join(' ');

      const result = substitutor.substitute(template);

      expect(result.metadata.duration).toBeLessThan(15); // <15ms for complex
    });
  });
});
```

---

### 2. NestedSubstitution.test.ts

**Purpose:** Test nested variable resolution

```typescript
import { describe, test, expect, beforeEach } from 'bun:test';
import { VariableSubstitutor } from '../../src/templates/VariableSubstitutor';
import { VariableStore } from '../../src/variables/VariableStore';
import { NestingDepthExceededError } from '../../src/templates/errors';

describe('Nested Variable Substitution', () => {
  let variableStore: VariableStore;
  let substitutor: VariableSubstitutor;

  beforeEach(() => {
    variableStore = new VariableStore(':memory:');
    substitutor = new VariableSubstitutor(variableStore);
  });

  test('should resolve single-level nested variables', () => {
    variableStore.set('basePath', '/home/user');
    variableStore.set('project', 'my-app');

    const result = substitutor.substitute('Path: ${basePath}/${project}');

    expect(result.output).toBe('Path: /home/user/my-app');
    expect(result.metadata.nestingDepth).toBe(0); // No nesting in this example
  });

  test('should resolve nested variable references', () => {
    variableStore.set('key', 'projectName');
    variableStore.set('projectName', 'MyApp');

    // This would require actual nested syntax support
    // For now, test that multiple passes work
    const result = substitutor.substitute('Value: ${projectName}');

    expect(result.output).toBe('Value: MyApp');
  });

  test('should enforce maximum nesting depth', () => {
    // Create deeply nested structure
    const deeplyNested = '${a${b${c${d${e${f}}}}}}'; // Depth 6

    expect(() => {
      substitutor.substitute(deeplyNested);
    }).toThrow(NestingDepthExceededError);
  });

  test('should allow configurable nesting depth', () => {
    const customSubstitutor = new VariableSubstitutor(variableStore, {
      maxNestingDepth: 10,
    });

    // Should not throw with higher limit
    // (Would need actual deeply nested variables to test properly)
    const result = customSubstitutor.substitute('${var}');
    expect(result).toBeDefined();
  });

  test('should track nesting depth in metadata', () => {
    variableStore.set('a', 'value-a');
    variableStore.set('b', 'value-b');

    const result = substitutor.substitute('${a} ${b}');

    expect(result.metadata.nestingDepth).toBeGreaterThanOrEqual(0);
  });
});
```

---

### 3. DefaultValues.test.ts

**Purpose:** Test default value fallback syntax

```typescript
import { describe, test, expect, beforeEach } from 'bun:test';
import { VariableSubstitutor } from '../../src/templates/VariableSubstitutor';
import { VariableStore } from '../../src/variables/VariableStore';

describe('Default Value Handling', () => {
  let variableStore: VariableStore;
  let substitutor: VariableSubstitutor;

  beforeEach(() => {
    variableStore = new VariableStore(':memory:');
    substitutor = new VariableSubstitutor(variableStore);
  });

  test('should use default when variable is undefined', () => {
    const result = substitutor.substitute('Env: ${environment:-production}');

    expect(result.output).toBe('Env: production');
    expect(result.errors).toHaveLength(0); // No error with default
  });

  test('should not use default when variable is defined', () => {
    variableStore.set('environment', 'development');

    const result = substitutor.substitute('Env: ${environment:-production}');

    expect(result.output).toBe('Env: development');
  });

  test('should handle empty string as valid value', () => {
    variableStore.set('optional', '');

    const result = substitutor.substitute('Value: ${optional:-default}');

    expect(result.output).toBe('Value: '); // Empty string is valid
  });

  test('should handle null vs undefined', () => {
    // Undefined -> use default
    const result1 = substitutor.substitute('${missing:-fallback}');
    expect(result1.output).toBe('fallback');

    // Explicit value -> use value
    variableStore.set('present', 'actual');
    const result2 = substitutor.substitute('${present:-fallback}');
    expect(result2.output).toBe('actual');
  });

  test('should handle default with special characters', () => {
    const result = substitutor.substitute('Path: ${path:-/usr/local/bin}');

    expect(result.output).toBe('Path: /usr/local/bin');
  });

  test('should handle multiple defaults in single template', () => {
    const result = substitutor.substitute(
      'Server: ${host:-localhost}:${port:-3000}'
    );

    expect(result.output).toBe('Server: localhost:3000');
  });

  test('should disable defaults when configured', () => {
    const noDefaultsSubstitutor = new VariableSubstitutor(variableStore, {
      useDefaultValues: false,
    });

    const result = noDefaultsSubstitutor.substitute('${env:-production}');

    // Without useDefaultValues, undefined variables cause errors
    expect(result.errors.length).toBeGreaterThan(0);
  });
});
```

---

### 4. EscapeSequences.test.ts

**Purpose:** Test escape sequence handling

```typescript
import { describe, test, expect, beforeEach } from 'bun:test';
import { VariableSubstitutor } from '../../src/templates/VariableSubstitutor';
import { VariableStore } from '../../src/variables/VariableStore';

describe('Escape Sequence Handling', () => {
  let variableStore: VariableStore;
  let substitutor: VariableSubstitutor;

  beforeEach(() => {
    variableStore = new VariableStore(':memory:');
    variableStore.set('variable', 'value');
    substitutor = new VariableSubstitutor(variableStore);
  });

  test('should preserve escaped variable syntax', () => {
    const result = substitutor.substitute('Literal: \\${notAVariable}');

    expect(result.output).toBe('Literal: ${notAVariable}');
  });

  test('should handle double escaping', () => {
    const result = substitutor.substitute('Escaped: \\\\${variable}');

    expect(result.output).toBe('Escaped: \\value');
  });

  test('should mix escaped and unescaped variables', () => {
    const result = substitutor.substitute(
      'Real: ${variable}, Literal: \\${notAVariable}'
    );

    expect(result.output).toBe('Real: value, Literal: ${notAVariable}');
  });

  test('should handle multiple escape sequences', () => {
    const result = substitutor.substitute(
      'Example: \\${foo} and \\${bar} are literals'
    );

    expect(result.output).toBe('Example: ${foo} and ${bar} are literals');
  });

  test('should not escape without backslash', () => {
    const result = substitutor.substitute('Not escaped: ${variable}');

    expect(result.output).toBe('Not escaped: value');
  });
});
```

---

### 5. SecurityTests.test.ts

**Purpose:** Test injection prevention and security validation

```typescript
import { describe, test, expect, beforeEach } from 'bun:test';
import { VariableSubstitutor } from '../../src/templates/VariableSubstitutor';
import { VariableStore } from '../../src/variables/VariableStore';
import { SecurityError } from '../../src/templates/errors';

describe('Security Tests', () => {
  let variableStore: VariableStore;
  let substitutor: VariableSubstitutor;

  beforeEach(() => {
    variableStore = new VariableStore(':memory:');
    substitutor = new VariableSubstitutor(variableStore);
  });

  describe('Variable Name Validation', () => {
    test('should allow valid variable names', () => {
      variableStore.set('validName', 'value');
      variableStore.set('valid_name', 'value');
      variableStore.set('valid-name', 'value');
      variableStore.set('valid.name', 'value');

      expect(() => {
        substitutor.substitute('${validName} ${valid_name} ${valid-name} ${valid.name}');
      }).not.toThrow();
    });

    test('should reject invalid variable names', () => {
      const maliciousInputs = [
        '${var!}',           // Special characters
        '${var@name}',       // @ symbol
        '${var#name}',       // # symbol
        '${var name}',       // Spaces
        '${var;name}',       // Semicolon
        '${var`cmd`}',       // Backticks
        '${var$(cmd)}',      // Command substitution
      ];

      for (const input of maliciousInputs) {
        expect(() => {
          substitutor.substitute(input);
        }).toThrow(SecurityError);
      }
    });
  });

  describe('Injection Prevention', () => {
    test('should not execute code in variable values', () => {
      variableStore.set('malicious', '`rm -rf /`');

      const result = substitutor.substitute('Command: ${malicious}');

      // Should be treated as plain string
      expect(result.output).toBe('Command: `rm -rf /`');
    });

    test('should handle SQL injection attempts', () => {
      variableStore.set('input', "'; DROP TABLE users; --");

      const result = substitutor.substitute('Query: ${input}');

      expect(result.output).toBe("Query: '; DROP TABLE users; --");
    });

    test('should handle script injection attempts', () => {
      variableStore.set('script', '<script>alert("XSS")</script>');

      const result = substitutor.substitute('HTML: ${script}');

      expect(result.output).toBe('HTML: <script>alert("XSS")</script>');
      // Note: Sanitization of output is responsibility of consumer
    });

    test('should handle path traversal attempts', () => {
      variableStore.set('path', '../../etc/passwd');

      const result = substitutor.substitute('Path: ${path}');

      expect(result.output).toBe('Path: ../../etc/passwd');
      // Note: Path validation is responsibility of consumer
    });
  });

  describe('DoS Prevention', () => {
    test('should limit nesting depth', () => {
      const deeplyNested = '${'.repeat(10) + 'var' + '}'.repeat(10);

      expect(() => {
        substitutor.substitute(deeplyNested);
      }).toThrow(NestingDepthExceededError);
    });

    test('should handle large variable counts efficiently', () => {
      // Create 1000 variables
      for (let i = 0; i < 1000; i++) {
        variableStore.set(`var${i}`, `value${i}`);
      }

      const template = Array.from({ length: 1000 }, (_, i) => `\${var${i}}`).join(' ');

      const startTime = performance.now();
      const result = substitutor.substitute(template);
      const duration = performance.now() - startTime;

      // Should still complete in reasonable time
      expect(duration).toBeLessThan(100); // <100ms for 1000 vars
      expect(result.variablesUsed).toHaveLength(1000);
    });
  });
});
```

---

### 6. SubstitutionPreview.test.ts

**Purpose:** Test preview functionality

```typescript
import { describe, test, expect, beforeEach } from 'bun:test';
import { SubstitutionPreviewGenerator } from '../../src/templates/SubstitutionPreview';
import { VariableSubstitutor } from '../../src/templates/VariableSubstitutor';
import { VariableStore } from '../../src/variables/VariableStore';

describe('SubstitutionPreview', () => {
  let variableStore: VariableStore;
  let substitutor: VariableSubstitutor;
  let previewGenerator: SubstitutionPreviewGenerator;

  beforeEach(() => {
    variableStore = new VariableStore(':memory:');
    substitutor = new VariableSubstitutor(variableStore);
    previewGenerator = new SubstitutionPreviewGenerator(
      variableStore,
      substitutor
    );
  });

  test('should generate preview with variable values', () => {
    variableStore.set('name', 'Alice');
    variableStore.set('project', 'MyApp');

    const preview = previewGenerator.generatePreview(
      'Hello ${name}, working on ${project}'
    );

    expect(preview.original).toBe('Hello ${name}, working on ${project}');
    expect(preview.substituted).toBe('Hello Alice, working on MyApp');
    expect(preview.variables).toHaveLength(2);
    expect(preview.variables[0].name).toBe('name');
    expect(preview.variables[0].value).toBe('Alice');
  });

  test('should format preview for terminal', () => {
    variableStore.set('env', 'production');

    const preview = previewGenerator.generatePreview('Environment: ${env}');
    const formatted = previewGenerator.formatForTerminal(preview);

    expect(formatted).toContain('Original Template:');
    expect(formatted).toContain('Substituted Output:');
    expect(formatted).toContain('Variables Used:');
    expect(formatted).toContain('env = "production"');
  });

  test('should track variable positions', () => {
    variableStore.set('var1', 'value1');

    const preview = previewGenerator.generatePreview('Prefix ${var1} suffix');

    expect(preview.variables[0].position.start).toBe(7); // Position of ${var1}
    expect(preview.variables[0].position.end).toBe(14);
  });
});
```

---

## Integration Tests

### template-substitution.integration.test.ts

**Purpose:** Test end-to-end workflows

```typescript
import { describe, test, expect, beforeEach } from 'bun:test';
import { TemplateEngine } from '../../src/templates/TemplateEngine';
import { VariableStore } from '../../src/variables/VariableStore';
import { ComputedVariableEngine } from '../../src/variables/ComputedVariableEngine';
import { EnvironmentVariableResolver } from '../../src/variables/EnvironmentVariableResolver';
import { TemplateSandbox } from '../../src/templates/TemplateSandbox';

describe('Template Substitution Integration', () => {
  let templateEngine: TemplateEngine;
  let variableStore: VariableStore;

  beforeEach(() => {
    variableStore = new VariableStore(':memory:');
    const sandbox = new TemplateSandbox({ maxExecutionTime: 5000, maxMemory: 10 * 1024 * 1024 });
    const computedEngine = new ComputedVariableEngine(sandbox);
    const envResolver = new EnvironmentVariableResolver();

    templateEngine = new TemplateEngine(
      sandbox,
      variableStore,
      computedEngine,
      envResolver
    );
  });

  test('should process complete template workflow', async () => {
    // Set up variables
    variableStore.set('projectName', 'MyApp');
    variableStore.set('version', '1.0.0');
    variableStore.set('author', 'Alice');

    const template = `
Project: \${projectName}
Version: \${version}
Author: \${author}
    `.trim();

    const result = await templateEngine.processTemplate(template);

    expect(result).toContain('Project: MyApp');
    expect(result).toContain('Version: 1.0.0');
    expect(result).toContain('Author: Alice');
  });

  test('should handle step-level variable overrides', async () => {
    variableStore.set('env', 'production'); // Global
    variableStore.set('env', 'development', 'step-1'); // Step-level

    const result = await templateEngine.processTemplate(
      'Environment: ${env}',
      'step-1'
    );

    expect(result).toBe('Environment: development');
  });
});
```

---

## Performance Benchmarks

### template-substitution.bench.ts

**Purpose:** Validate performance targets

```typescript
import { bench, describe } from 'bun:test';
import { VariableSubstitutor } from '../packages/core/src/templates/VariableSubstitutor';
import { VariableStore } from '../packages/core/src/variables/VariableStore';

describe('Variable Substitution Performance', () => {
  const variableStore = new VariableStore(':memory:');
  const substitutor = new VariableSubstitutor(variableStore);

  // Setup variables
  for (let i = 0; i < 100; i++) {
    variableStore.set(`var${i}`, `value${i}`);
  }

  bench('simple template (1-5 variables)', () => {
    const template = 'Hello ${var0}, you have ${var1} messages';
    substitutor.substitute(template);
  });

  bench('typical template (10-50 variables)', () => {
    const template = Array.from({ length: 30 }, (_, i) => `\${var${i}}`).join(' ');
    substitutor.substitute(template);
  });

  bench('complex template (50-100 variables)', () => {
    const template = Array.from({ length: 80 }, (_, i) => `\${var${i}}`).join(' ');
    substitutor.substitute(template);
  });

  bench('template with defaults', () => {
    const template = 'Env: ${env:-production}, Port: ${port:-3000}';
    substitutor.substitute(template);
  });

  bench('template with escapes', () => {
    const template = 'Real: ${var0}, Literal: \\${notAVar}';
    substitutor.substitute(template);
  });
});
```

**Expected Results:**

```
Variable Substitution Performance
  simple template (1-5 variables):     0.5ms  ✅ Target: <1ms
  typical template (10-50 variables):  3.2ms  ✅ Target: <5ms
  complex template (50-100 variables): 12.1ms ✅ Target: <15ms
  template with defaults:              0.8ms  ✅ Target: <5ms
  template with escapes:               1.1ms  ✅ Target: <5ms
```

---

## Running Tests

### All Tests

```bash
# Run all tests
bun test

# Run specific test file
bun test packages/core/tests/templates/VariableSubstitutor.test.ts

# Run with coverage
bun test --coverage

# Run in watch mode
bun test --watch
```

### Performance Benchmarks

```bash
# Run benchmarks
bun test tests/benchmarks/template-substitution.bench.ts

# Run with iterations
bun test tests/benchmarks/template-substitution.bench.ts --iterations 1000
```

### Mutation Testing

```bash
# Run mutation tests (requires StrykerJS)
bun run test:mutation

# Expected mutation score: >85%
```

---

## Test Checklist

Before marking story complete:

- [ ] All unit tests passing (80+ tests)
- [ ] All integration tests passing (15+ tests)
- [ ] All performance benchmarks passing (8 benchmarks)
- [ ] All security tests passing (15+ tests)
- [ ] Test coverage >90%
- [ ] Mutation score >85%
- [ ] No flaky tests
- [ ] All edge cases covered

---

**Guide Version:** 1.0
**Last Updated:** 2025-10-10
**Author:** Bob (Scrum Master)
**Status:** Complete
