# Story 3.4 Implementation Guide

**Story:** 3.4 - Basic Template Substitution
**Epic:** 3 - Templates & Security
**Target Package:** `packages/core/src/templates/`
**Estimated Time:** 2-3 days

## Quick Start

### Prerequisites

Before starting implementation, ensure:

1. ✅ Story 3.3 (Variable Management System) is **Done**
2. ✅ Story 3.1 (Template Loading) is **Done**
3. ✅ Story 3.2 (Template Security) is **Done**
4. ✅ All tests from previous stories are passing
5. ✅ Development environment is set up (Bun 1.1.x, TypeScript 5.9+)

### Implementation Checklist

```bash
# Run this before starting
bun run quality         # Ensure codebase is clean
bun test               # All tests passing
git status             # Working tree clean
```

## Step-by-Step Implementation

### Phase 1: Setup (30 minutes)

#### Step 1.1: Create File Structure

```bash
# From project root
cd packages/core/src/templates

# Create new files
touch VariableSubstitutor.ts
touch SubstitutionPreview.ts

# Update existing files (we'll modify these)
# - types.ts
# - errors.ts
# - TemplateEngine.ts
# - index.ts
```

#### Step 1.2: Update types.ts

Add these type definitions to `packages/core/src/templates/types.ts`:

```typescript
// Add to existing types
import type { VariableValue } from '../variables/types';

export interface SubstitutionConfig {
  maxNestingDepth: number;
  allowUndefinedVariables: boolean;
  useDefaultValues: boolean;
  enableCaching: boolean;
  escapePattern: string;
}

export interface SubstitutionContext {
  variables: Record<string, VariableValue>;
  stepId?: string;
  config: SubstitutionConfig;
}

export interface SubstitutionResult {
  output: string;
  variablesUsed: string[];
  errors: SubstitutionError[];
  metadata: {
    duration: number;
    variableCount: number;
    nestingDepth: number;
  };
}

export interface SubstitutionError {
  variableName: string;
  message: string;
  suggestions?: string[];
}

export interface SubstitutionPreview {
  original: string;
  substituted: string;
  variables: VariablePreview[];
}

export interface VariablePreview {
  name: string;
  value: VariableValue;
  position: { start: number; end: number };
  highlighted: boolean;
}
```

#### Step 1.3: Update errors.ts

Add new error classes to `packages/core/src/templates/errors.ts`:

```typescript
// Add to existing error classes

export class VariableSubstitutionError extends Error {
  constructor(
    message: string,
    public variableName: string,
    public suggestions?: string[]
  ) {
    super(message);
    this.name = 'VariableSubstitutionError';
  }
}

export class NestingDepthExceededError extends Error {
  constructor(
    public maxDepth: number,
    public currentDepth: number
  ) {
    super(
      `Maximum nesting depth of ${maxDepth} exceeded (current: ${currentDepth})`
    );
    this.name = 'NestingDepthExceededError';
  }
}

export class SecurityError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'SecurityError';
  }
}
```

---

### Phase 2: Core Implementation (4-6 hours)

#### Step 2.1: Implement VariableSubstitutor (Core)

Create `packages/core/src/templates/VariableSubstitutor.ts`:

```typescript
import type { VariableStore } from '../variables/VariableStore';
import type { VariableValue } from '../variables/types';
import type {
  SubstitutionConfig,
  SubstitutionResult,
  SubstitutionError,
} from './types';
import {
  VariableSubstitutionError,
  NestingDepthExceededError,
  SecurityError,
} from './errors';
import { createLogger } from '../utils/logger';

const logger = createLogger('checklist:templates:substitutor');

export class VariableSubstitutor {
  // Regex patterns (compiled once for performance)
  private static readonly VARIABLE_PATTERN =
    /\$\{([a-zA-Z0-9_.-]+)(?::-(.*?))?\}/g;
  private static readonly ESCAPE_PATTERN = /\\(\$\{[^}]+\})/g;
  private static readonly NESTED_PATTERN = /\$\{([^}]*\$\{[^}]+\}[^}]*)\}/;
  private static readonly ALLOWED_VARIABLE_NAME = /^[a-zA-Z0-9_.-]+$/;

  private readonly config: SubstitutionConfig;

  constructor(
    private variableStore: VariableStore,
    config?: Partial<SubstitutionConfig>
  ) {
    this.config = {
      maxNestingDepth: 5,
      allowUndefinedVariables: false,
      useDefaultValues: true,
      enableCaching: true,
      escapePattern: '\\',
      ...config,
    };
  }

  /**
   * Main substitution method
   * Replaces ${variable} patterns with values from VariableStore
   */
  substitute(template: string, stepId?: string): SubstitutionResult {
    const startTime = performance.now();
    const variablesUsed: string[] = [];
    const errors: SubstitutionError[] = [];

    // Early exit optimization
    if (!template.includes('${')) {
      return {
        output: template,
        variablesUsed: [],
        errors: [],
        metadata: { duration: 0, variableCount: 0, nestingDepth: 0 },
      };
    }

    // Step 1: Process escape sequences
    const unescaped = this.processEscapes(template);

    // Step 2: Resolve nested variables (recursive with depth limit)
    let output = unescaped;
    let nestingDepth = 0;

    while (
      VariableSubstitutor.NESTED_PATTERN.test(output) &&
      nestingDepth < this.config.maxNestingDepth
    ) {
      output = this.resolveVariables(output, stepId, variablesUsed, errors);
      nestingDepth++;
    }

    // Check if we exceeded nesting depth
    if (
      nestingDepth >= this.config.maxNestingDepth &&
      VariableSubstitutor.NESTED_PATTERN.test(output)
    ) {
      throw new NestingDepthExceededError(
        this.config.maxNestingDepth,
        nestingDepth
      );
    }

    // Step 3: Final pass for any remaining variables
    output = this.resolveVariables(output, stepId, variablesUsed, errors);

    // Step 4: Restore escaped sequences
    output = this.restoreEscapes(output);

    const duration = performance.now() - startTime;

    // Log performance metrics
    logger.info({
      msg: 'Variable substitution completed',
      duration,
      variableCount: variablesUsed.length,
      nestingDepth,
      errorCount: errors.length,
    });

    return {
      output,
      variablesUsed: Array.from(new Set(variablesUsed)),
      errors,
      metadata: { duration, variableCount: variablesUsed.length, nestingDepth },
    };
  }

  /**
   * Resolve all variables in the text
   */
  private resolveVariables(
    text: string,
    stepId: string | undefined,
    variablesUsed: string[],
    errors: SubstitutionError[]
  ): string {
    return text.replace(
      VariableSubstitutor.VARIABLE_PATTERN,
      (match, varName, defaultValue) => {
        // Validate variable name
        if (!VariableSubstitutor.ALLOWED_VARIABLE_NAME.test(varName)) {
          throw new SecurityError(`Invalid variable name: ${varName}`);
        }

        variablesUsed.push(varName);

        // Get variable from store (handles scope resolution)
        const value = this.variableStore.get(varName, stepId);

        if (value !== undefined) {
          return this.formatValue(value);
        }

        // Use default value if provided
        if (
          defaultValue !== undefined &&
          this.config.useDefaultValues
        ) {
          return defaultValue;
        }

        // Handle undefined variable
        if (!this.config.allowUndefinedVariables) {
          const error = this.createUndefinedVariableError(varName);
          errors.push(error);
          return match; // Keep original for error visibility
        }

        return '';
      }
    );
  }

  /**
   * Format variable value as string
   */
  private formatValue(value: VariableValue): string {
    if (typeof value === 'string') return value;
    if (typeof value === 'number') return value.toString();
    if (typeof value === 'boolean') return value.toString();
    if (Array.isArray(value)) return value.join(', ');
    return String(value);
  }

  /**
   * Process escape sequences - replace with placeholders
   */
  private processEscapes(text: string): string {
    return text.replace(
      VariableSubstitutor.ESCAPE_PATTERN,
      (match, escaped) => {
        const encoded = Buffer.from(escaped).toString('base64');
        return `__ESCAPED_${encoded}__`;
      }
    );
  }

  /**
   * Restore escaped sequences - decode placeholders
   */
  private restoreEscapes(text: string): string {
    return text.replace(/__ESCAPED_([A-Za-z0-9+/=]+)__/g, (match, base64) => {
      return Buffer.from(base64, 'base64').toString('utf8');
    });
  }

  /**
   * Create error with fuzzy-matched suggestions
   */
  private createUndefinedVariableError(varName: string): SubstitutionError {
    const availableVars = Object.keys(this.variableStore.getAll());
    const suggestions = this.fuzzyMatch(varName, availableVars);

    logger.warn({
      msg: 'Undefined variable',
      variableName: varName,
      suggestions,
      availableCount: availableVars.length,
    });

    return {
      variableName: varName,
      message: `Variable '${varName}' is not defined`,
      suggestions,
    };
  }

  /**
   * Fuzzy match for typo suggestions (Levenshtein distance)
   */
  private fuzzyMatch(target: string, candidates: string[]): string[] {
    return candidates
      .map((candidate) => ({
        candidate,
        distance: this.levenshteinDistance(target, candidate),
      }))
      .filter((item) => item.distance <= 3)
      .sort((a, b) => a.distance - b.distance)
      .slice(0, 3)
      .map((item) => item.candidate);
  }

  /**
   * Calculate Levenshtein distance between two strings
   */
  private levenshteinDistance(a: string, b: string): number {
    const matrix: number[][] = [];

    for (let i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1, // substitution
            matrix[i][j - 1] + 1,     // insertion
            matrix[i - 1][j] + 1      // deletion
          );
        }
      }
    }

    return matrix[b.length][a.length];
  }
}
```

**Key Implementation Notes:**

- ✅ Uses compiled regex patterns for performance
- ✅ Validates variable names against security pattern
- ✅ Handles nested variables with depth limit
- ✅ Provides fuzzy matching for typo suggestions
- ✅ Structured logging with Pino
- ✅ Early exit optimization for templates without variables

#### Step 2.2: Implement SubstitutionPreview

Create `packages/core/src/templates/SubstitutionPreview.ts`:

```typescript
import type { VariableStore } from '../variables/VariableStore';
import type { VariableValue } from '../variables/types';
import type { SubstitutionPreview, VariablePreview } from './types';
import { VariableSubstitutor } from './VariableSubstitutor';

export class SubstitutionPreviewGenerator {
  constructor(
    private variableStore: VariableStore,
    private substitutor: VariableSubstitutor
  ) {}

  /**
   * Generate preview showing original, substituted, and variable values
   */
  generatePreview(template: string, stepId?: string): SubstitutionPreview {
    const result = this.substitutor.substitute(template, stepId);
    const variables = this.extractVariablePositions(
      template,
      result.variablesUsed,
      stepId
    );

    return {
      original: template,
      substituted: result.output,
      variables,
    };
  }

  /**
   * Format preview for terminal display
   */
  formatForTerminal(preview: SubstitutionPreview): string {
    let output = '\n';
    output += '📝 Original Template:\n';
    output += `  ${preview.original}\n\n`;

    output += '✅ Substituted Output:\n';
    output += `  ${preview.substituted}\n\n`;

    if (preview.variables.length > 0) {
      output += '🔧 Variables Used:\n';
      for (const variable of preview.variables) {
        const valueStr = this.formatValue(variable.value);
        output += `  ${variable.name} = ${valueStr}\n`;
      }
    } else {
      output += '⚠️  No variables found in template\n';
    }

    return output;
  }

  /**
   * Extract variable positions and values
   */
  private extractVariablePositions(
    template: string,
    variableNames: string[],
    stepId?: string
  ): VariablePreview[] {
    const previews: VariablePreview[] = [];
    const pattern = /\$\{([a-zA-Z0-9_.-]+)(?::-(.*?))?\}/g;

    let match: RegExpExecArray | null;
    while ((match = pattern.exec(template)) !== null) {
      const varName = match[1];
      if (variableNames.includes(varName)) {
        const value = this.variableStore.get(varName, stepId);
        previews.push({
          name: varName,
          value: value ?? null,
          position: { start: match.index, end: match.index + match[0].length },
          highlighted: true,
        });
      }
    }

    return previews;
  }

  /**
   * Format variable value for display
   */
  private formatValue(value: VariableValue | null): string {
    if (value === null) return '<undefined>';
    if (typeof value === 'string') return `"${value}"`;
    if (typeof value === 'number') return value.toString();
    if (typeof value === 'boolean') return value.toString();
    if (Array.isArray(value)) return `[${value.join(', ')}]`;
    return String(value);
  }
}
```

---

### Phase 3: Integration (2-3 hours)

#### Step 3.1: Update TemplateEngine

Modify `packages/core/src/templates/TemplateEngine.ts`:

```typescript
// Add import
import { VariableSubstitutor } from './VariableSubstitutor';

export class TemplateEngine {
  private substitutor: VariableSubstitutor;

  constructor(
    private sandbox: TemplateSandbox,
    private variableStore: VariableStore,
    private computedEngine: ComputedVariableEngine,
    private envResolver: EnvironmentVariableResolver
  ) {
    // Initialize substitutor
    this.substitutor = new VariableSubstitutor(variableStore, {
      maxNestingDepth: 5,
      allowUndefinedVariables: false,
      useDefaultValues: true,
      enableCaching: true,
      escapePattern: '\\',
    });
  }

  /**
   * Process template with variable substitution
   */
  async processTemplate(template: string, stepId?: string): Promise<string> {
    // Step 1: Pre-evaluate computed variables
    // (Computed variables are stored in VariableStore by ComputedVariableEngine)
    // This happens before substitution

    // Step 2: Perform variable substitution (NEW)
    const result = this.substitutor.substitute(template, stepId);

    if (result.errors.length > 0) {
      throw new TemplateProcessingError(
        'Variable substitution failed',
        result.errors
      );
    }

    // Step 3: Log performance metrics
    logger.info({
      msg: 'Template processed successfully',
      duration: result.metadata.duration,
      variableCount: result.metadata.variableCount,
      nestingDepth: result.metadata.nestingDepth,
    });

    return result.output;
  }
}
```

#### Step 3.2: Update index.ts

Update `packages/core/src/templates/index.ts`:

```typescript
// Add exports
export { VariableSubstitutor } from './VariableSubstitutor';
export { SubstitutionPreviewGenerator } from './SubstitutionPreview';

// Export types
export type {
  SubstitutionConfig,
  SubstitutionContext,
  SubstitutionResult,
  SubstitutionError,
  SubstitutionPreview,
  VariablePreview,
} from './types';

// Export errors
export {
  VariableSubstitutionError,
  NestingDepthExceededError,
  SecurityError,
} from './errors';
```

---

### Phase 4: Testing (4-6 hours)

See the separate [Testing Guide](./3.4-testing-guide.md) for comprehensive test implementation.

---

## Development Workflow

### Daily Checklist

```bash
# Morning: Start fresh
git pull origin main
bun install
bun run quality

# During development
bun test --watch        # Run tests continuously
bun run lint           # Check linting
bun run typecheck      # Check types

# Before commit
bun run quality        # All checks pass
bun test              # All tests pass
bun test:coverage     # Check coverage
```

### Debugging Tips

**1. Enable Debug Logging**

```typescript
// Set environment variable
Bun.env.LOG_LEVEL = 'debug';

// Or in code
import { createLogger } from '../utils/logger';
const logger = createLogger('checklist:templates:substitutor', 'debug');
```

**2. Use Performance Profiling**

```typescript
const startTime = performance.now();
const result = substitutor.substitute(template);
const duration = performance.now() - startTime;

if (duration > 5) {
  logger.warn({
    msg: 'Slow substitution detected',
    duration,
    variableCount: result.metadata.variableCount,
  });
}
```

**3. Test with Real Templates**

```bash
# Create test template
cat > /tmp/test-template.txt << 'EOF'
Hello ${name},

Your project ${project} is located at ${basePath}/${project}.
Environment: ${env:-production}

Literal example: \${notAVariable}
EOF

# Test in REPL
bun repl
> import { VariableSubstitutor } from './packages/core/src/templates/VariableSubstitutor'
> // Test your code interactively
```

---

## Common Pitfalls

### ❌ Pitfall 1: Using eval or Function

```typescript
// ❌ NEVER DO THIS - Security vulnerability
const result = eval(`\`${template}\``);

// ✅ CORRECT - Safe string replacement
const result = template.replace(pattern, (match) => value);
```

### ❌ Pitfall 2: Not Validating Variable Names

```typescript
// ❌ BAD - Allows injection
const value = variableStore.get(varName);

// ✅ GOOD - Validate first
if (!ALLOWED_VARIABLE_NAME.test(varName)) {
  throw new SecurityError(`Invalid variable name: ${varName}`);
}
const value = variableStore.get(varName);
```

### ❌ Pitfall 3: Infinite Recursion

```typescript
// ❌ BAD - Can loop forever
while (NESTED_PATTERN.test(output)) {
  output = resolveVariables(output);
}

// ✅ GOOD - Depth limit
let depth = 0;
while (NESTED_PATTERN.test(output) && depth < maxDepth) {
  output = resolveVariables(output);
  depth++;
}
```

---

## Performance Optimization

### Compile Regex Once

```typescript
// ✅ GOOD - Class-level static
private static readonly VARIABLE_PATTERN = /\$\{([a-zA-Z0-9_.-]+)\}/g;

// ❌ BAD - Recompiles every call
substitute(template: string) {
  return template.replace(/\$\{([a-zA-Z0-9_.-]+)\}/g, ...);
}
```

### Early Exit for Non-Templates

```typescript
// Skip processing if no variables
if (!template.includes('${')) {
  return { output: template, ... };
}
```

### Use Performance.now() for Accurate Timing

```typescript
const startTime = performance.now(); // High-resolution timestamp
// ... processing ...
const duration = performance.now() - startTime; // Milliseconds
```

---

## Sign-Off Criteria

Before marking the story as complete, verify:

- [ ] All 10 tasks completed
- [ ] All acceptance criteria met (8 ACs)
- [ ] Unit test coverage >90%
- [ ] Performance benchmarks pass (<5ms for typical templates)
- [ ] Security tests pass (injection prevention)
- [ ] Integration tests pass
- [ ] No linting errors
- [ ] No type errors
- [ ] Documentation updated
- [ ] Code review completed

---

## Getting Help

If you encounter issues:

1. **Check Previous Stories**
   - Story 3.3: Variable Management System
   - Story 3.1: Template Loading
   - Story 3.2: Template Security

2. **Review Architecture Docs**
   - `docs/architecture/tech-stack.md`
   - `docs/architecture/coding-standards.md`
   - `docs/architecture/testing-strategy.md`

3. **Run Diagnostics**
   ```bash
   bun run quality        # Check code quality
   bun test --verbose     # Detailed test output
   bun run lint --debug   # Lint with debug info
   ```

4. **Debug Logging**
   ```bash
   LOG_LEVEL=debug bun test
   ```

---

**Guide Version:** 1.0
**Last Updated:** 2025-10-10
**Author:** Bob (Scrum Master)
**Status:** Complete
