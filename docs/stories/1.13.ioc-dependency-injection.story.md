# Story 1.13: IoC/Dependency Injection Pattern Implementation

## Status
Draft

## Story
**As a** developer,  
**I want** to implement Inversion of Control and Dependency Injection patterns for all services,  
**So that** components are properly decoupled, testable, and maintainable.

## Acceptance Criteria
1. Define service interfaces for all major components (ILogger, IStateManager, etc.)
2. Implement concrete service classes that fulfill interface contracts
3. Create mock implementations for all service interfaces for testing
4. Establish IoC container or factory pattern for dependency resolution
5. All services use constructor injection (no global instances)
6. Service provider pattern implemented for runtime configuration
7. Full test coverage using mock services only
8. Migration guide for converting existing code to DI pattern
9. No performance degradation from DI overhead (<1ms per injection)

## Tasks / Subtasks

- [ ] **Task 1: Create Directory Structure & Core Service Interfaces** (AC: 1)
  - [ ] Create directory structure: `packages/core/src/interfaces/` if not exists
  - [ ] Create directory structure: `packages/core/src/container/` if not exists
  - [ ] Create ILogger interface in `packages/core/src/interfaces/ILogger.ts`
  - [ ] Create IStateManager interface in `packages/core/src/interfaces/IStateManager.ts`
  - [ ] Create IWorkflowEngine interface in `packages/core/src/interfaces/IWorkflowEngine.ts`
  - [ ] Create IConfigService interface in `packages/core/src/interfaces/IConfigService.ts`
  - [ ] Create IFileSystemService interface in `packages/core/src/interfaces/IFileSystemService.ts`
  - [ ] Export all interfaces from `packages/core/src/interfaces/index.ts`

- [ ] **Task 2: Enhance Existing Container Implementation** (AC: 4, 5, 6)
  - [ ] Extend existing Container class from architecture (backend-architecture.md:161)
  - [ ] Add constructor injection support to existing Container
  - [ ] Implement ServiceProvider wrapper class in `packages/core/src/container/ServiceProvider.ts`
  - [ ] Add debugging capabilities (container inspection, dependency graph)
  - [ ] Implement circular dependency detection enhancements
  - [ ] Add service lifecycle hooks (onInit, onDestroy, onError)
  - [ ] Create ContainerDebugger class for development diagnostics

- [ ] **Task 3: Implement Concrete Service Classes** (AC: 2)
  - [ ] Create adapter for existing LoggerService to implement ILogger
  - [ ] Preserve existing singleton for backward compatibility initially
  - [ ] Create StateManagerService implementing IStateManager
  - [ ] Create WorkflowEngineService implementing IWorkflowEngine
  - [ ] Create ConfigService implementing IConfigService
  - [ ] Create BunFileSystemService implementing IFileSystemService
  - [ ] Ensure all services extend BaseService class from architecture

- [ ] **Task 4: Create Mock Service Implementations** (AC: 3, 7)
  - [ ] Create directory: `packages/core/tests/mocks/` if not exists
  - [ ] Create MockLoggerService with spy capabilities
  - [ ] Create MockStateManagerService with state simulation
  - [ ] Create MockWorkflowEngineService with workflow mocking
  - [ ] Create MockConfigService with config overrides
  - [ ] Create MockFileSystemService with virtual filesystem
  - [ ] Extend existing TestDataFactory for mock service data

- [ ] **Task 5: Phased Migration Implementation - Phase 1** (AC: 8)
  - [ ] Create migration guide in `docs/development/dependency-injection-migration.md`
  - [ ] Document phased approach with rollback points
  - [ ] Implement compatibility layer for gradual migration
  - [ ] Create feature flag system for DI enablement
  - [ ] Migrate non-critical services first (ConfigService, FileSystemService)
  - [ ] Document rollback procedure for each phase

- [ ] **Task 6: Phased Migration Implementation - Phase 2** (AC: 8)
  - [ ] Migrate LoggerService with backward compatibility wrapper
  - [ ] Update logger consumers to use interface gradually
  - [ ] Migrate StateManager and WorkflowEngine
  - [ ] Verify no breaking changes in existing functionality
  - [ ] Performance comparison before/after migration

- [ ] **Task 7: Service Configuration & Lifecycle System** (AC: 6)
  - [ ] Create ServiceConfiguration interface
  - [ ] Implement configuration loader with environment support
  - [ ] Create service bindings for dev/test/prod environments
  - [ ] Implement comprehensive lifecycle hooks:
    - [ ] beforeInit, afterInit
    - [ ] beforeDestroy, afterDestroy
    - [ ] onError with recovery strategies
  - [ ] Add health check capabilities for services

- [ ] **Task 8: Write Comprehensive Tests** (AC: 7)
  - [ ] Create Bun test configuration for DI tests
  - [ ] Unit tests for enhanced Container functionality
  - [ ] Unit tests for ServiceProvider and lifecycle management
  - [ ] Integration tests for phased migration scenarios
  - [ ] Test rollback procedures
  - [ ] Test circular dependency detection
  - [ ] Verify mock services work with StrykerJS mutation testing
  - [ ] Achieve 90%+ test coverage for DI system

- [ ] **Task 9: Performance Testing and Optimization** (AC: 9)
  - [ ] Establish baseline metrics for current implementation
  - [ ] Create Tinybench benchmarks for service injection
  - [ ] Measure injection overhead (target: <1ms)
  - [ ] Implement service resolution caching strategy
  - [ ] Profile memory usage of container
  - [ ] Document performance metrics and optimization results

- [ ] **Task 10: Documentation and Rollback Strategy**
  - [ ] Complete migration guide with examples
  - [ ] Document rollback procedures for each migration phase
  - [ ] Create troubleshooting guide for common DI issues
  - [ ] Document container debugging tools usage
  - [ ] Create service lifecycle diagram
  - [ ] Add DI patterns best practices guide

## Dev Notes

### Architecture Context

**IMPORTANT: Existing Container Implementation** [Source: architecture/backend-architecture-complete-with-all-services.md:161-198]:
- An existing Container class already exists in the architecture
- Task 2 should ENHANCE this existing implementation, not create a new one
- Add constructor injection and debugging capabilities to the existing Container

**Base Service Template** [Source: architecture/backend-architecture-complete-with-all-services.md:7-33]:
```typescript
export abstract class BaseService {
  protected logger: Logger;
  protected config: ServiceConfig;
  protected dependencies: Map<string, BaseService> = new Map();

  constructor(config: ServiceConfig, logger: Logger) {
    this.config = config;
    this.logger = logger;
  }

  async initialize(): Promise<void> {
    this.logger.debug(`Initializing ${this.constructor.name}`);
    await this.onInitialize();
  }

  async shutdown(): Promise<void> {
    this.logger.debug(`Shutting down ${this.constructor.name}`);
    await this.onShutdown();
  }

  inject(name: string, service: BaseService): void {
    this.dependencies.set(name, service);
  }

  protected abstract onInitialize(): Promise<void>;
  protected abstract onShutdown(): Promise<void>;
}
```

**Project Structure for Services** [Source: architecture/source-tree.md#project-structure]:
- Service interfaces: `/packages/core/src/interfaces/`
- Concrete services: `/packages/core/src/services/`
- Mock implementations: `/packages/core/tests/mocks/`
- Container system: `/packages/core/src/container/`
- Tests location: `/packages/core/tests/`

**Existing Logger Integration** [Source: packages/core/src/utils/logger.ts]:
- Current LoggerService is a singleton (line 95-98)
- Already has Logger interface defined (lines 15-25)
- PinoLoggerWrapper implements the Logger interface (lines 43-72)
- Migration strategy: Create adapter pattern to preserve singleton initially
- Phased approach: Replace singleton gradually with injected service

**Previous Story Context** [Source: Story 1.12 Dev Agent Record]:
- StrykerJS mutation testing is configured and operational
- Test environment detection uses STRYKER_MUTATOR_RUNNER flag
- All tests must be mockable for mutation testing compatibility
- Current mutation score at 62.32%, need to improve with better test assertions

**Tech Stack Requirements** [Source: architecture/tech-stack.md]:
- Runtime: Bun 1.1.x
- Language: TypeScript 5.3.x with strict mode
- Testing: Bun Test (built-in)
- Logging: Pino 9.x
- Performance Testing: Tinybench 2.5.x

**Coding Standards Requirements** [Source: architecture/coding-standards.md]:
- All services must follow ESLint rules with TypeScript strict mode
- No console.log - use injected logger service
- Imports must be organized and sorted
- No global instances allowed
- All async operations must use AbortController pattern

**Monorepo Package Dependencies** [Source: architecture/coding-standards.md#monorepo-dependency-rules]:
- CLI → Core ✓
- TUI → Core ✓
- Core → CLI ❌ (Core cannot depend on CLI)
- Core → TUI ❌ (Core cannot depend on TUI)
- Shared can be used by all packages

### Phased Migration Strategy

**Phase 1 - Non-Critical Services** (Low Risk):
1. ConfigService - New implementation
2. FileSystemService - New implementation  
3. Feature flag: `DI_ENABLED=partial`
4. Rollback: Remove new services, revert feature flag

**Phase 2 - Logger Migration** (Medium Risk):
1. Create LoggerServiceAdapter wrapping existing singleton
2. Gradually replace direct LoggerService usage
3. Feature flag: `DI_LOGGER_ENABLED=true`
4. Rollback: Revert to direct singleton usage

**Phase 3 - Core Services** (High Risk):
1. StateManager and WorkflowEngine migration
2. Full DI pattern adoption
3. Feature flag: `DI_ENABLED=full`
4. Rollback: Restore previous service implementations

### Container Debugging Capabilities

**Development Tools**:
```typescript
interface IContainerDebugger {
  inspectService(name: string): ServiceMetadata;
  getDependencyGraph(): DependencyGraph;
  listRegisteredServices(): string[];
  getServiceLifecycleState(name: string): LifecycleState;
  enableVerboseLogging(): void;
}
```

**Debug Features**:
- Service resolution tracing
- Circular dependency visualization
- Memory usage per service
- Injection performance metrics
- Service health status dashboard

### Service Lifecycle Hooks

**Available Hooks**:
1. **beforeInit**: Pre-initialization setup
2. **afterInit**: Post-initialization verification
3. **beforeDestroy**: Cleanup preparation
4. **afterDestroy**: Resource verification
5. **onError**: Error recovery strategies
6. **healthCheck**: Service health validation

**Hook Implementation Example**:
```typescript
lifecycle: {
  beforeInit: async (service) => { /* setup */ },
  afterInit: async (service) => { /* verify */ },
  onError: async (error, service) => { /* recover */ },
  healthCheck: async (service) => { /* validate */ }
}
```

### Rollback Strategy

**Per-Phase Rollback Points**:
1. **Feature Flags**: Environment-based DI enablement
2. **Compatibility Layer**: Maintains existing API surface
3. **Service Registry Snapshot**: Before each migration phase
4. **Performance Benchmarks**: Automated rollback on degradation
5. **Health Checks**: Automatic rollback on service failure

**Rollback Procedure**:
```bash
# 1. Disable feature flag
export DI_ENABLED=false

# 2. Restore previous service implementations
git checkout HEAD~1 -- packages/core/src/services/

# 3. Clear service registry cache
rm -rf .checklist/.container-cache/

# 4. Restart application
bun run dev
```

### Testing Requirements

**Test Standards** [Source: architecture/testing-strategy-complete-with-all-testing-utilities.md]:
- Tests must be colocated with source files (`.test.ts`)
- Use TestDataFactory for creating test data  
- All services must be fully mockable
- Mutation testing threshold: 85% minimum
- Performance tests must validate <1ms injection overhead using Tinybench

**Bun Test Configuration**:
```typescript
// packages/core/tests/container/setup.ts
import { beforeEach, afterEach } from 'bun:test';

beforeEach(() => {
  // Reset container state
  global.testContainer = new Container();
});

afterEach(() => {
  // Cleanup injected services
  global.testContainer?.reset();
});
```

**Test File Locations**:
- Unit tests: `/packages/core/tests/container/*.test.ts`
- Mock services: `/packages/core/tests/mocks/*.ts`
- Integration tests: `/packages/core/tests/integration/*.test.ts`
- Performance tests: `/packages/core/tests/benchmarks/*.bench.ts`

### Testing

- **Test file location**: `/packages/core/tests/`
- **Test standards**: Bun Test with StrykerJS mutation testing
- **Testing frameworks**: Bun Test (built-in), Tinybench for performance benchmarking
- **Specific requirements**: 
  - 85% mutation score minimum (StrykerJS threshold)
  - <1ms injection overhead (performance requirement)
  - All services must be fully mockable
  - Tests must be colocated with source files (`.test.ts`)
  - Use TestDataFactory for creating test data

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-09 | 1.0 | Initial story creation for IoC/DI implementation | Bob (SM) |
| 2025-01-09 | 1.1 | Enhanced with phased migration, rollback strategy, debugging capabilities, and lifecycle hooks | Sarah (PO) |
| 2025-01-09 | 1.2 | Fixed BaseService reference (line 7, not 161); Added Testing subsection per template requirements | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
[To be filled by Dev Agent]

### Debug Log References
[To be filled by Dev Agent]

### Completion Notes List
[To be filled by Dev Agent]

### File List
[To be filled by Dev Agent]

## QA Results
[To be filled by QA Agent]