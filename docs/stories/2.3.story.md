# Story 2.3: Core Navigation Commands

## Status

Done

## Story

**As a** user,
**I want** intuitive keyboard commands for workflow navigation,
**so that** I can progress efficiently through my checklist.

## Acceptance Criteria

1. 'n'/Enter advances to next step
2. 'd' marks done and auto-advances
3. 's' skips with confirmation
4. 'b' goes back to previous step
5. 'r' resets to beginning
6. 'l' toggles list view
7. '?' shows help overlay
8. 'q' quits with unsaved check
9. Visual feedback for all actions
10. Command queueing prevents race conditions

## Tasks / Subtasks

- [x]  Create Core Navigation Handler (AC: 1,2,4,5,9,10)
  - [x]  Create `packages/tui/src/navigation/NavigationCommandHandler.ts` class
  - [x]  Implement command registration system with EventBus integration
  - [x]  Add state validation and race condition prevention with command queueing
  - [x]  Integrate with existing ViewSystem state management
  - [x]  Add visual feedback system using performance monitoring
- [x]  Implement Primary Navigation Commands (AC: 1,2,4,5)
  - [x]  Implement 'n'/Enter: advance to next step with state validation
  - [x]  Implement 'd': mark current step as done and auto-advance
  - [x]  Implement 'b': go back to previous step with history management
  - [x]  Implement 'r': reset to beginning with confirmation dialog
  - [x]  Add state persistence for navigation changes
- [x]  Implement Secondary Navigation Commands (AC: 3,6,7,8)
  - [x]  Implement 's': skip step with confirmation dialog
  - [x]  Implement 'l': toggle between list and detail views
  - [x]  Implement '?': show help overlay using existing modal system
  - [x]  Implement 'q': quit with unsaved changes check
- [x]  Add Visual Feedback System (AC: 9)
  - [x]  Create command feedback animations using existing ANSI rendering
  - [x]  Add status indicators for command success/failure
  - [x]  Implement progress indicators for state changes
  - [x]  Add keyboard shortcut hints in status bar
- [x]  Implement Command Queueing System (AC: 10)
  - [x]  Create command queue with FIFO processing
  - [x]  Add debouncing for rapid key presses
  - [x]  Implement command validation before execution
  - [x]  Add error handling for failed commands with recovery
  - [x]  Add specific recovery scenarios: command timeout, invalid state transitions, queue overflow, EventBus disconnection
- [x]  Unit Testing Implementation
  - [x]  Test NavigationCommandHandler class with mock dependencies
  - [x]  Test all navigation commands with state validation
  - [x]  Test command queueing and race condition prevention
  - [x]  Test visual feedback system output validation
  - [x]  Performance test: all commands must execute within <50ms requirement
  - [x]  Establish performance baseline: measure current navigation response times before implementation
  - [x]  Create benchmark suite for command execution times, queue processing, and visual feedback rendering

## Dev Notes

### Previous Story Insights

Story 2.2 successfully implemented DetailPanel and MarkdownRenderer components with comprehensive testing and performance optimization. The ViewSystem integration is established and working properly. Key technical patterns established:

- BaseComponent extension for lifecycle management
- ComponentRegistry integration for proper registration
- Performance monitoring with <50ms validation
- Comprehensive error handling and graceful degradation

### Data Models

**Step Navigation State** [Source: architecture/data-models.md#Step]:

```typescript
interface Step {
  id: string;
  title: string;
  description: string;
  type: 'task' | 'confirmation' | 'input' | 'automated' | 'multi-command';
  commands: Command[];
}

// Navigation state will need to track:
interface NavigationState {
  currentStepId: string;
  previousStepId?: string;
  completedSteps: string[];
  skippedSteps: string[];
  hasUnsavedChanges: boolean;
  viewMode: 'list' | 'detail';
}
```

**Command Structure** [Source: architecture/data-models.md#Command]:

```typescript
interface Command {
  id: string;
  type: 'claude' | 'bash' | 'internal'; // Navigation commands are 'internal'
  content: string;
  dangerous: boolean;
  requiresConfirmation: boolean;
}
```

### API Specifications

No REST API endpoints required for this story - pure TUI navigation functionality.

### Component Specifications

**TUI Framework Context** [Source: architecture/tech-stack.md#TUI/CLI Framework]:

- Custom ANSI Terminal UI rendering (v1.0.0) for command feedback
- Custom ViewSystem (v1.0.0) for state management integration
- Custom EventBus (v1.0.0) for keyboard event processing
- Custom PerformanceMonitor (v1.0.0) for <50ms validation

**Event System Integration** [Source: architecture/source-tree.md#events]:

- EventManager.ts: Central event coordination
- KeyboardHandler.ts: Keyboard input processing
- EventBus.ts: Event routing and handling
- InputValidator.ts: Command validation

**Component Architecture** [Source: architecture/components.md]:

- View System (#7) manages screen state and navigation
- Terminal Canvas (#8) provides visual feedback rendering
- TUI Renderer (#6) handles all terminal UI updates

### File Locations

Based on project structure [Source: architecture/source-tree.md]:

- **Navigation Handler**: `packages/tui/src/navigation/NavigationCommandHandler.ts`
- **Command Queue**: `packages/tui/src/navigation/CommandQueue.ts` (new file)
- **Visual Feedback**: `packages/tui/src/components/NavigationFeedback.ts` (new file)
- **Tests Location**: `packages/tui/tests/navigation/NavigationCommandHandler.test.ts`
- **Integration with**: Existing EventBus at `packages/tui/src/events/EventBus.ts`
- **State Integration**: Existing ViewSystem at `packages/tui/src/views/ViewSystem.ts`

### Testing Requirements

[Source: architecture/testing-strategy.md]

- **Framework**: Bun test runner (built-in)
- **Test Location**: `packages/tui/tests/navigation/`
- **Coverage Target**: >85% for TUI navigation components
- **Performance Tests**: Use Tinybench for <50ms validation
- **Integration Testing**: Test with EventBus and ViewSystem
- **Flaky Test Detection**: Use FlakyTestDetector for command timing tests

### Technical Constraints

[Source: architecture/coding-standards.md]:

- ESLint rules must pass - no `any` types allowed
- Maximum 80 character line width (Prettier)
- Use Pino logger from `@checklist/core/utils/logger`
- Follow import ordering: builtin → external → internal
- No console.log - use debug logger instead

**Performance Requirements** [Source: architecture/tech-stack.md#Performance Testing]:

- Command execution time: <50ms (critical for responsiveness)
- Memory usage: Stay within baseline limits during navigation
- Use PerformanceMonitor from Story 1.8 for metrics tracking
- Queue processing must not block UI thread

**Event Handling Patterns** [Source: story 2.2 implementation notes]:

- Use existing EventBus system for keyboard events
- Implement proper event cleanup and memory management
- Follow established patterns for component lifecycle
- Use WeakMap/WeakSet for object metadata as per coding standards

### Project Structure Notes

The TUI package structure is properly set up at `packages/tui/src/` with:

- Navigation infrastructure at `navigation/` (NavigationStack.ts, ViewRegistry.ts)
- Event handling system at `events/` (EventManager.ts, KeyboardHandler.ts)
- Component registry at `components/` (ComponentRegistry.ts, BaseComponent.ts)
- Performance monitoring at `performance/` (PerformanceMonitor.ts)

Navigation command handlers will integrate into this existing infrastructure without structural conflicts.

### Implementation Specifics

**Command Registration Pattern**:

- NavigationCommandHandler extends BaseComponent for lifecycle management
- Register commands with EventBus using structured command objects
- Use existing KeyboardHandler for input processing
- Leverage ViewSystem for state management and transitions

**Visual Feedback Implementation**:

- Use existing ANSI rendering system from Terminal Canvas
- Implement status indicators with ansis package (already in dependencies)
- Follow established patterns from DetailPanel for visual updates
- Use existing performance monitoring for feedback timing

**Command Queueing Architecture**:

- FIFO queue with debouncing (200ms default)
- Command validation before execution
- Race condition prevention through state locking
- Error recovery with user notification

**State Management Integration**:

- Integrate with existing ViewSystem navigation stack
- Use established state persistence patterns from Story 2.2
- Maintain navigation history for 'b' (back) command
- Implement unsaved changes detection for 'q' (quit) command

**Security Considerations**:

- Input sanitization for confirmation dialog text ('s' skip, 'r' reset, 'q' quit)
- Command validation before queue processing to prevent injection
- State lock validation to ensure atomic navigation operations
- User input validation for navigation commands to prevent malformed state

## Testing

### Test File Location

`packages/tui/tests/navigation/NavigationCommandHandler.test.ts`
`packages/tui/tests/navigation/CommandQueue.test.ts`
`packages/tui/tests/navigation/NavigationIntegration.test.ts`

### Test Standards

- Use Bun test runner with native testing capabilities
- Coverage target: >85% for NavigationCommandHandler component
- Include unit tests for all navigation commands
- Include integration tests with EventBus and ViewSystem
- Add performance tests using Tinybench for <50ms validation
- Test command queueing and race condition prevention

### Testing Frameworks and Patterns

- Unit Testing: Bun Test (built-in)
- Performance Testing: Tinybench (already in devDependencies)
- Flaky Test Detection: FlakyTestDetector for timing-sensitive tests
- Visual Testing: Snapshot testing for command feedback output

### Specific Testing Requirements for This Story

1. Test all 8 navigation commands individually with state validation
2. Verify command queueing prevents race conditions under rapid input
3. Test visual feedback system output and timing
4. Validate state persistence after navigation commands
5. Test help overlay display and content
6. Test quit command with unsaved changes detection
7. Performance benchmark: all commands must execute <50ms
8. Integration test with EventBus and ViewSystem components
9. Test keyboard input handling edge cases
10. Test command validation and error recovery

## Change Log


| Date       | Version | Description                 | Author             |
| ---------- | ------- | --------------------------- | ------------------ |
| 2025-09-26 | 1.0     | Initial story draft created | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4 (claude-sonnet-4-20250514)

### Debug Log References

- NavigationCommandHandler implementation: packages/tui/src/navigation/NavigationCommandHandler.ts
- CommandQueue implementation: packages/tui/src/navigation/CommandQueue.ts
- NavigationFeedback component: packages/tui/src/components/NavigationFeedback.ts
- PerformanceMonitor enhancement: packages/tui/src/performance/PerformanceMonitor.ts
- AlertManager enhancement: packages/tui/src/performance/helpers/AlertManager.ts

### Completion Notes List

1. Successfully implemented all 8 navigation commands (n, Enter, d, b, r, s, l, ?, q) with proper event handling
2. Command queueing system prevents race conditions with priority-based processing and retry logic
3. Visual feedback system provides real-time status updates with command indicators
4. Performance monitoring tracks command execution times with <50ms validation
5. Comprehensive test suites cover unit, integration, and performance scenarios
6. All acceptance criteria fulfilled with robust error handling and state validation

### File List

**New Files Created:**
- packages/tui/src/navigation/NavigationCommandHandler.ts - Core navigation command processor
- packages/tui/src/navigation/CommandQueue.ts - Command queuing with debouncing and retry logic
- packages/tui/src/components/NavigationFeedback.ts - Visual feedback system for commands
- packages/tui/tests/navigation/NavigationCommandHandler.test.ts - Comprehensive unit tests
- packages/tui/tests/navigation/CommandQueue.test.ts - Command queue test suite
- packages/tui/tests/navigation/NavigationFeedback.test.ts - Visual feedback tests
- packages/tui/tests/navigation/NavigationIntegration.test.ts - End-to-end integration tests

**Modified Files:**
- packages/tui/src/performance/PerformanceMonitor.ts - Added recordCommandExecution method
- packages/tui/src/performance/helpers/AlertManager.ts - Added recordAlert method and enhanced PerformanceAlert interface

## QA Results

### Review Date: 2025-09-26

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

The navigation command system demonstrates exceptional implementation quality with well-architected components, comprehensive error handling, and excellent test coverage. The code follows established patterns and maintains clean separation of concerns between command handling, queueing, and visual feedback.

### Refactoring Performed

- **File**: packages/tui/src/components/NavigationFeedback.ts
  - **Change**: Refactored getStatusIndicator method to use configuration object pattern
  - **Why**: Eliminated switch statement redundancy and improved type safety with const assertions
  - **How**: Replaced imperative switch with declarative configuration object lookup, reducing cyclomatic complexity

### Compliance Check

- Coding Standards: ✓ All ESLint rules pass, no 'any' types used
- Project Structure: ✓ Follows established monorepo patterns and file organization
- Testing Strategy: ✓ Comprehensive unit, integration, and performance tests with >90% coverage
- All ACs Met: ✓ All 10 acceptance criteria fully implemented and tested

### Improvements Checklist

- [x] Refactored NavigationFeedback getStatusIndicator method for better maintainability
- [x] Fixed TypeScript strict boolean expressions linting issue
- [x] Verified all tests pass after refactoring
- [ ] Consider adding load testing for extreme command volume scenarios
- [ ] Add integration test for queue overflow recovery scenario

### Security Review

No security concerns identified. Input validation is properly implemented for all navigation commands, keyboard events are filtered by source, and command validation prevents injection attacks.

### Performance Considerations

All performance requirements met. Navigation commands execute within <50ms threshold with comprehensive performance monitoring integration. Command queueing prevents race conditions with appropriate debouncing.

### Files Modified During Review

- packages/tui/src/components/NavigationFeedback.ts - Refactored status indicator logic

### Gate Status

Gate: PASS → docs/qa/gates/2.3-core-navigation-commands-review-gate.yml
Risk profile: docs/qa/assessments/2.3-risk-20250926.md
NFR assessment: docs/qa/assessments/2.3-nfr-20250926.md

### Recommended Status

✓ Ready for Done

### Finalization: 2025-09-26

**Status Updated**: Done
**Finalized By**: Claude Code /story-finalize command
**Documentation**: Updated all project references
**Flatten Operation**: Completed successfully
**Commits**: All changes committed and pushed
